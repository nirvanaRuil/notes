# Vue

**自定义指令**:是在仍然需要对DOM进行底层操作时.样式什么的不需要插入到DOM树中就可以渲染到页面上,但是DOM行为不行.   分全局指令`directive`和私有指令`directives` .

`Vue.directive('指令名称',{bind:function(el,binding){}})`    

简写式-包含bind和update钩子函数:`'指令名称':function(el,binding){}`

**路由懒加载**:`const home = () => import("地址")` 在router.js中导入

**vue.js的两个核心是什么**:数据驱动,组件系统.

**npm run build带来的问题**:都是路径格式的问题,打开`webpack.config.js`文件,修改assetsPublicPath为相对路径.

插值表达式中可以放入简单的js表达式:`{{msg.split()}}` .

**监听机制**:

- **计算属性computed**.本质上是vue实例对象上的一个属性. 会自动监测数据源的改变：只有数据源发生变化才会重新执行计算属性，否则会返回缓存中的上次的计算结果。**计算属性的监听适用于多对一的场景，即某个组件内的一个数据(add)会受多个数据(num1,num2)的影响(比如add=num1+num2)(多个影响一个)。**不限制响应式依赖(就是data中的数据,在computed里是this.msg)的个数和数据类型,会多个同时监听 .    比methods先执行,要写在methods前面.   不能用箭头函数,会使指向混乱.    默认深度监听.   其中的函数必须用return返回.    使用情景:例如商品结算,计算总值时.
- **监听器watch**:**`watch`的监听适用于一对多(一个影响多个)的场景**，即某个组件内的一个数据的改变会影响其他多个数据。  设置`deep:true`或者直接点(.)到想监听的数据上,才会深度监听.    适用场景:例如搜索框.

**MVVM和MVC架构模式的区别**:这些架构模式的目的都只有两个:1.怎么管理响应用户操作的业务逻辑;2.View怎么同步Model的变更.

**现在常用的是服务端的MVC**,服务端接收到来自客户端的请求后,通过路由规则把这个请求交由给特定的Controller进行处理，Controller执行相应的业务逻辑，对数据库数据（Model）进行操作，然后用数据去渲染特定的模版，返回给客户端。这个MVC中的V指的就是前端.     **在vue中应用的模式是MVVM**.在MVVM中View和ViewModel相互依赖,ViewModel依赖Model.VM中有一个叫Binder的东西,它的作用是你只需要在view模板语法中,指令式的声明 显示内容是和Model中哪部分数据绑定的,然后当View和Model进行更新的时候,Binder就会自动进行双向数据绑定,自动化了View和Model的同步逻辑.这种模式的优点是低耦合,可测试(针对VM对界面进行测试),可重用,可以进行独立开发(独立开发业务逻辑和数据,独立开发界面设计).

(问到就说)还知道MVP模式,MVVM是由MVP演化而来,MVP没有双向绑定.

**观察者模式又叫发布-订阅模式**.定义**对象间一种一对多的关系**,当一个对象的状态发生改变时,所有依赖于它的对象都会得到通知和更新.   对象订阅(观察者)事件并在发生时得到通知

**Vue双向绑定原理**: 核心是 `Object.defineProperty()`方法,采用观察者模式,主要通过4个步骤来实现数据双向绑定:实现一个监听器 Observer---实现一个解析器 Compile---实现一个订阅者 Watcher---实现一个订阅器 Dep . 剩下的我记不太清了我只会用.

**data为什么必须是函数**:因为如果是对象的话,data属性值都会在一个共有的数据空间中,各个组件中的data值就会相互影响.如果是函数,那么每个data的返回值都有独立空间.

**key的作用**:key 因为key值是唯一的不变的,除了解决list渲染过程中一些隐蔽的 bug，提高渲染效率，以及在使用相同标签名元素的过渡切换时区分节点以外， **最主要的用途还是在 diff 算法中** 。可以高效的更新虚拟DOM. 在patch过程中通过key精准判断是否同一个节点,使整个patch的过程减少DOM操作量,提高性能.

**虚拟DOM的作用**:通过比对并局部更新DOM,以达到性能优化的目的.

**diff算法**:diff的过程就是调用名为`patch`的函数，比较新旧节点，一边比较一边给真实的DOM打补丁。     当数据发生改变时，set方法会让调用`Dep.notify`通知所有订阅者Watcher，订阅者就会调用`patch`给真实的DOM打补丁，更新相应的视图。

**父给子传值**:父组件中通过绑定事件`v-bind:传递名称 = '需要传递的值'`,这样父组件的操作就完成了，然后在子组件中，通过`props[]`来接收从父组件传过来的值，接受到的值就可在子组件的template中使用。

**子给父传值**:子组件给需要传递的值绑定事件,然后在methods中用`this.$emit(组件方法名,传递的数据)` .在父组件方法中引入子组件的自定义事件,完成接收.

**非父子传值**:简历一个公共的js文件,在需要接受的地方用bus.$on接受消息.

大型项目不适合用父子组件传值,耦合太强,要用vuex.

**data和props的区别**:data可读可写,数据是本身就私有的,比如axios请求回来的数据就可以放到data中;props不可更改,数据都是通过父组件传递过来的.

**vuex状态管理模式**:放在store文件夹中.挂载到实例中(main.js).有四个部分:state--包含vuex中的各种状态,getter---类似于计算属性,mutation---方法,改变store中状态的执行者,只能是同步操作;action---包含异步操作的方法.  当项目过于庞大状态非常多时,可以采用模块化管理模式,也就是采用Models.

**生命周期**:Vue 实例从创建到销毁的过程，就是生命周期。  一共有八个阶段--创建前/后,挂载前/后,更新前/后(beforeUpdate/updated),销毁前/后(beforeDestroy/distroy).    它的作用是在生命周期中有多个事件钩子，让我们在控制整个Vue实例的过程时更容易形成好的逻辑。 第一次页面加载会触发beforeCreate,created;beforeMount, mounted.   DOM渲染在mounted中就已经完成了 . 

虚拟DOM重新渲染和打补丁在beforeUpdate和updated之间进行.  `created`时完成数据观测,data和methods初始化完成;`mounted`时完成把模板中的html渲染到html页面中。此过程中进行ajax交互。

**事件循环event loop**:先执行同步任务,然后执行微任务队列,再执行宏任务队列(宏任务每次执行一个,然后在执行微任务,执行完所有微任务再执行下一个宏任务).

**router-link(命令路线)&router-view(命令视图)**: <router-link  to:"目标路由">--链接到目标路由;router-view相当于一个占位符,展示对应的视图.

**nextTick()**:当数据更新了，在dom中渲染后，自动执行该函数.

# ES6

**模板字符串` 反引号${}反引号 `** :${}中的是变量,用来代替复杂的引号加加号的拼接方法,很方便简洁.

**let和const**:都是声明块级作用域.都不存在变量提升. const声明的变量不能重复赋值(变量指向的内存地址所保存的数据不得改动),let可以.    for循环中使用var声明循环变量时,会跳出循环体污染当前函数.     实际开发中选择let/const/var取决于我们的变量是否需要更新.

**this**:**this永远指向最后调用它的那个对象**,而在箭头函数中的this指向函数定义时的this.,不是执行时的this.  匿名函数this指向window.

 **改变this指向**:使用ES6箭头函数;在函数内部使用`_this=this`;使用apply,call,bind;new实例化一个对象.   apply和call的区别是---apply传入的是参数列表,call是参数数组.

**箭头函数**:没有this.没有原型.不能使用new.

**尾调用优化**:在函数return的时候调用一个新的函数. 由于尾调用的实现需要存储到内存中,在一个循环中如果存在尾调用,内存可能溢出.  es6会帮你做好优化工作,只要这个函数不是闭包;尾调用是函数最后一条语句;尾调用的结果最为函数返回.  实际用于递归函数优化.

**Object.assign()**: 拷贝时只拷贝一层,也就是说拷贝的只是对象的引用,如果你改了其中一个数据,那么原对象和拷贝对象都会改变,使用Object.assign()就可以;深拷贝拷贝的是每一层的数据,所以拷贝对象是完全独立出来的,用`JSON.parse(JSON.stringify(obj))`,先将对象转为json字符串,再转回json对象.

**Map和Set**: map和set都是集合,但是set常用来检查对象中是否存在某个键名,map被用来获取已存信息.  Set是有序列表,含有相互独立的非重复值.

**数组新方法**: `forEach()`,`map()`,`filter()`,`every()`,`find()`,`some()`,`reduce()`.

**扩展运算符**:将一个数组转为用逗号分隔的参数序列还可以将字符串转为真正的数组.

**兼容问题?** :怎么处理兼容性问题?首先要以最大程度完善设计稿为基础,再考虑兼容性,有两种处理观点:

**渐进增强**：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。**优雅降级**：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。     **区别**：优雅降级是从复杂的现状开始，并试图减少用户体验的供给，而渐进增强则是从一个非常基础的、能够起作用的版本开始，并不断扩充,以便于适应未来环境。降级意味着往回看,增强意味着朝前看,同时让根基处于安全地带.    **Hack写法:**_color(IE6生效);*color(IE7生效).     **Css Reset**:将浏览器的默认样式全部去掉,重新定义标签样式,覆盖浏览器的css默认属性.     **条件注释**:可以用来向IE提供隐藏代码.

**常见的兼容问题**: 默认样式存在差异:直接*{margin:0;padding:0;}  ;  **事件绑定**:标准的事件绑定方法函数为`addEventListener()`，但IE下是`attachEvent()`.IE里事件对象仅存在于window.event参数中。(event,target解决方法,用三元表达式) .   获取目标元素的方法不同，标准浏览器是event.target，而IE下是event.srcElement.  事件必须以ontype的方式命名.比如:onclick而不是click.

**常见的浏览器兼容问题**:1. 块属性标签float后，又有横向的margin情况下，在[IE6](http://xiazai.zol.com.cn/detail/11/102978.shtml)显示margin比设置的大:解决方案--在float的标签样式控制中加入 display:inline;转化为行内属性 ; 2.图片默认有间距:使用float布局 ; 3.若需给 a 标签内内容加上样式, 需要设置 display: block;(常见于导航标签) ; 4.设置较小高度标签（一般小于10px），在IE6，[IE7](http://xiazai.zol.com.cn/detail/14/130213.shtml)，遨游中高度超出自己设置高度:给超出高度的标签设置overflow:hidden;或者设置行高line-height 小于你设置的高度。

**addEventListener()**:此方法设定一个事件监听器,当某一事件发生通过设定的参数执行操作.参数1-坚挺的事件(必须);参数2-触发后调用的函数(必须).

**JS性能优化**:1.-资源加载方面-:合并文件以减少浏览器请求;使用defer和async属性,都是并行下载,区别在于async是下载完后立即执行,defer立即下载延迟执行并且只适用于外部文件.  2.-代码优化-:减少DOM操作,DOM操作最耗性能;减少访问全局变量,因为访问当前作用域外的变量时间会增加. 3.-网络请求-:尽量减少http的请求次数;合理设置http缓存. 4.-使用资源预加载-.

**CSS优化**:提取通有样式,增强可复用性;使用预处理器或者构建工具(gulp工具可以进行语法检查,自动优雅降级等)

**cookies，sessionStorage 和 localStorage 的区别**:`cookie`是网站为了标示用户身份而储存在用户本地终端上的数据（通常经过加密）,它的数据始终在同源的http请求中携带，会在浏览器和服务器间来回传递;而`sessionStorage`和`localStorage`不会自动把数据发给服务器，仅在本地保存.      在数据大小方面也有差别:`cookie`不能超过4k,其他两个有好几兆,比cookie大得多.      `Cookie`可以设置数据存储时间,`localStorage`长期存储数据,关闭浏览器数据不丢失;`sessionStorage`关闭浏览器后数据自动删除.

**Promise**:三个状态---pending[待定]初始状态;fulfilled[实现]操作成功
;rejected[被否决]操作失败.     promise的方法:   `.then()`   `.catch()`   `.all()`把多个promise实例包装成一个       `.race()`也是把多个promise实例包装成一个       `.resolve()`将现有对象转为promise对象       `.reject()`返回一个状态为reject的实例      `.finally()`不管promise状态如何都会执行操作         promise的应用一般与generator/yield结合,而async又是generator的语法糖

**Async/await**:`Async/await`其实是`generator/yield`的语法糖.generator函数从内部向外返回数据,并且会分段执行,yield语句就是就是暂停执行的标记.generator函数的特点是分段执行可以暂停;可以控制阶段和每个阶段的返回值;可以知道是否进行到结尾.async函数的返回值总是返回promise实例,await用在async函数中,后面是promise实例,如果不是则会用promise.resolve()转为实例,所以就有了比较精简的写法.await左边的变量就是promise成功后的resolve数据.

**px和rem和em的区别**:都是长度单位,但是px值是固定的便于计算;em值不固定,是相对单位,会继承父级元素的字体大小。比如字体默认16px,那么1em=16px。    Em和rem区别在于使用rem为元素设定字体大小时，仍然是相对大小，但相对的只是HTML根元素。通过它既可以做到只修改根元素就成比例地调整所有字体大小，又可以避免字体大小逐层复合的连锁反应。

**BFC布局规则**:全称是块格式化上下文。可以形成一个独立容器,不受外界影响,从而解决一些布局问题.        BFC的触发条件也挺多的,比如说float的值不为none的时候;position的值为fixed或者absolute的时候。display,overflow

同一个BFC下外边距会发生折叠。如果想要避免外边距的重叠，可以将其放在不同的 BFC 容器中。

规则:1.内部的块级元素会在垂直方向，一个接一个地放置；  2.块级元素垂直方向的距离由margin决定。属于同一个BFC的两个相邻的块级元素会发生margin合并，不属于同一个BFC的两个相邻的块级元素不会发生margin合并；  3.每个元素的margin box的左边，与包含border box的左边相接触（对于从左往右的格式化，否则相反）。即使存在浮动也是如此；  4.BFC的区域不会与float box重叠；  5.BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会在布局上影响到外面的元素；外面的元素也不会影响到容器里面的子元素,并且 BFC 具有普通容器所没有的一些特性；  6.计算BFC的高度时，浮动元素也参与计算

**box-sizing有两个值**:center-box(标准模型),border-box(怪异模型)

**flex及适用场景**:Css3新功能,用来为盒装模型提供最大的灵活性,任何一个容器都可以指定为flex布局.通过给父盒添加flex来控制子盒的位置和排列方式,flex中默认子元素不换行.更适用于移动端布局.

如果要水平垂直居中,同时设置主轴和侧轴的居中.

**父盒主要属性**有:flex-direction决定主轴的方向(横向或纵向),剩下的一个就是侧轴; justify-content项目在主轴上的对齐方式(center居中对齐,space-between两边对齐,space-around项目两侧间隔相等);align-items项目在交叉轴(侧轴)上如何对齐.

**子盒主要属性**:flex属性定义子项目分配剩余空间,用flex来表示占多少份数,默认值0,还可以写百分比,表示每个子项目占父级宽度的百分比.如果要平均分配空间就能写成flex:1;
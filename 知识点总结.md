# Vue

**自定义指令**:是在仍然需要对DOM进行底层操作时.样式什么的不需要插入到DOM树中就可以渲染到页面上,但是DOM行为不行.   分全局指令`directive`和私有指令`directives` .

`Vue.directive('指令名称',{bind:function(el,binding){}})`    

简写式-包含bind和update钩子函数:`'指令名称':function(el,binding){}`

**路由懒加载**:`const home = () => import("地址")` 在router.js中导入

**vue.js的两个核心是什么**:数据驱动,组件系统.

**npm run build(打包)带来的问题**:都是路径格式的问题,打开`webpack.config.js`文件,修改assetsPublicPath为相对路径.

插值表达式中可以放入简单的js表达式:`{{msg.split()}}` .

**Ajax的过程:**（1）创建XMLHttpRequest对象,也就是创建一个异步调用对象（2）创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息（3）设置响应HTTP请求状态变化的函数（4）发送HTTP请求（5）获取异步调用返回的数据（6）使用JavaScript和DOM实现局部刷新

**监听机制**:

- **计算属性computed**.本质上是vue实例对象上的一个属性. 会自动监测数据源的改变：只有数据源发生变化才会重新执行计算属性，否则会返回缓存中的上次的计算结果。**计算属性的监听适用于多对一的场景，即某个组件内的一个数据(add)会受多个数据(num1,num2)的影响(比如add=num1+num2)(多个影响一个)。**不限制响应式依赖(就是data中的数据,在computed里是this.msg)的个数和数据类型,会多个同时监听 .    比methods先执行,要写在methods前面.   不能用箭头函数,会使指向混乱.    默认深度监听.   其中的函数必须用return返回.    使用情景:例如商品结算,计算总值时.
- **监听器watch**:**`watch`的监听适用于一对多(一个影响多个)的场景**，即某个组件内的一个数据的改变会影响其他多个数据。  设置`deep:true`或者直接点(.)到想监听的数据上,才会深度监听.    适用场景:例如搜索框.

**MVVM和MVC架构模式的区别**:这些架构模式的目的都只有两个:1.怎么管理响应用户操作的业务逻辑;2.View怎么同步Model的变更.

**现在常用的是服务端的MVC**,服务端接收到来自客户端的请求后,通过路由规则把这个请求交由给特定的Controller进行处理，Controller执行相应的业务逻辑，对数据库数据（Model）进行操作，然后用数据去渲染特定的模版，返回给客户端。这个MVC中的V指的就是前端.     **在vue中应用的模式是MVVM**.在MVVM中View和ViewModel相互依赖,ViewModel依赖Model.VM中有一个叫Binder的东西,它的作用是你只需要在view模板语法中,指令式的声明 显示内容是和Model中哪部分数据绑定的,然后当View和Model进行更新的时候,Binder就会自动进行双向数据绑定,自动化了View和Model的同步逻辑.这种模式的优点是低耦合,可测试(针对VM对界面进行测试),可重用,可以进行独立开发(独立开发业务逻辑和数据,独立开发界面设计).

MVP模式,MVVM是由MVP演化而来,MVP没有双向绑定.

**观察者模式又叫发布-订阅模式**.定义**对象间一种一对多的关系**,当一个对象的状态发生改变时,所有依赖于它的对象都会得到通知和更新.   对象订阅(观察者)事件并在发生时得到通知

**Vue双向绑定原理**: 核心是 `Object.defineProperty()`方法,采用观察者模式,主要通过4个步骤来实现数据双向绑定:实现一个监听器 Observer---实现一个解析器 Compile---实现一个订阅者 Watcher---实现一个订阅器 Dep . 剩下的我记不太清了我只会用.

**data为什么必须是函数**:因为如果是对象的话,data属性值都会在一个共有的数据空间中,各个组件中的data值就会相互影响.如果是函数,那么每个data的返回值都有独立空间.

**key的作用**:因为我们需要key来给每个节点做一个唯一标识,在diff算法中通过key精准判断是否同一个节点,来高效的更新虚拟DOM.在patch过程中通过key精准判断是否同一个节点,使整个patch的过程减少DOM操作量,提高性能. 除此之外,在使用相同标签名元素的过渡切换时，也会使用到key,让vue可以区分它们.

**虚拟DOM的作用**:通过比对并局部更新DOM,以达到性能优化的目的.

**diff算法**:diff的过程就是调用名为`patch`的函数，比较新旧节点，一边比较一边给真实的DOM打补丁。     当数据发生改变时，set方法会让调用`Dep.notify`通知所有订阅者Watcher，订阅者就会调用`patch`给真实的DOM打补丁，更新相应的视图。

**父给子传值**:父组件中通过绑定属性`v-bind:传递名称 = '需要传递的值'`,子组件中，通过`props[]`来接收从父组件传过来的值，接受到的值就可在子组件的template中使用。

**子给父传值**:子组件给需要传递的值绑定事件,然后在methods中用`this.$emit(组件方法名,传递的数据)` .在父组件方法中引入子组件的自定义事件,完成接收.

**非父子传值**:建立一个公共的js文件,在需要接受的地方用bus.$on接受消息.

大型项目不适合用父子组件传值,耦合太强,要用vuex.

**data和props的区别**:data可读可写,数据是本身就私有的,比如axios请求回来的数据就可以放到data中;props不可更改,数据都是通过父组件传递过来的.

**vuex状态管理模式**:放在store文件夹中.挂载到实例中(main.js).有四个部分:state--包含vuex中的各种状态,getter---类似于计算属性,mutation---方法,改变store中状态的执行者,只能是同步操作;action---包含异步操作的方法.  当项目过于庞大状态非常多时,可以采用模块化管理模式,也就是采用Models.

## **vue中$router和$route的使用**

**$router**是vue-router的实例,相当于一个全局路由对象,里面有很多属性和子对象.常用的跳转链接就可以用this.$router.push,和router-link跳转一样. 而**$route**是当前正在跳转的路由对象,可以从里面获取name,path,params等对象.

## **vue-router原理**

前端路由的核心之一就是更新视图但不重新请求页面,通过hash和History interface(H5新特性)两种方式实现. 路由的mode参数决定采用哪种方式,默认是hash(#)方式. 当你选择mode类型之后，程序会根据你选择的mode 类型创建不同的history对象(HashHistory或HTML5History或AbstractHistory). hash方式下可以用push和replace替换路由---push将新路由添加到浏览器访问历史的栈顶,而replace直接替换当前路由. history可以读取浏览器历史记录栈的信息并修改.

## **vue-路由守卫(导航守卫)**

导航守卫也叫路由拦截,有三种:全局守卫,路由独享守卫和组件内守卫. 

**全局守卫**分为全局前置导航钩子和全局后置导航钩子.在路由即将改变前和改变后触发. 前置调用router.beforeEach((to,from,next) => {}) .有三个参数:to是进入到哪个路由去,from是从哪个路由离开,next决定是否展示你要看到的路由页面.   应用过程是这样的---判断to将要进入的路径,如果是,执行next()展示将要进入的路径.   next在所有逻辑路径都不重叠的情况下可以出现一至多次,否则函数不被解析或报错.   next()--直接进to 所指路由 ; next(false)--中断当前路由 ; next('route')--跳转指定路由 ; next('error')--跳转错误路由. 后置用的少,调用router.afterEach((to,from) => {}) ,只有to和from两个参数.

**路由独享守卫**调用beforeEnter:(to,from,next) => {},与全局守卫用法一致,唯一区别只是独享守卫作用在一个路由对象中,只在这个路由中起作用.

**组件内守卫**有三个钩子函数:beforeRouteEnter(to,from,next) => {}路由进入组件之前时,此时next用法有些不同,因为实例还未渲染,所以要调用vm来访问实例 ; beforeRouteUpdate(to,from,next) => {}刷新不同数据时 ; beforeRouteLeave(to,from,next) => {}离开当前路由组件时调用.

**生命周期**:Vue 实例从创建到销毁的过程，就是生命周期。  一共有八个阶段--创建前/后,挂载前/后,更新前/后(beforeUpdate/updated),销毁前/后(beforeDestroy/distroy).    它的作用是在生命周期中有多个事件钩子，让我们在控制整个Vue实例的过程时更容易形成好的逻辑。 第一次页面加载会触发beforeCreate,created;beforeMount, mounted.   DOM渲染在mounted中就已经完成了 . 

虚拟DOM重新渲染和打补丁在beforeUpdate和updated之间进行.  `created`时完成数据观测,data和methods初始化完成;`mounted`时完成把模板中的html渲染到html页面中。此过程中进行ajax交互。

**事件循环event loop**:先执行同步任务,然后执行微任务队列,再执行宏任务队列(宏任务每次执行一个,然后在执行微任务,执行完所有微任务再执行下一个宏任务).

**router-link(命令路线)&router-view(命令视图)**: <router-link  to:"目标路由">--链接到目标路由;router-view相当于一个占位符,展示对应的视图.

**nextTick()**:当数据更新了，在dom中渲染后，自动执行该函数.

**v-if和v-for的使用方式**  **:同时使用时v-for的优先级高于v-if, 每一次都需要遍历整个数组，将会影响速度,所以不推荐同时使用.       如果非要同时使用建议把v-if放在外层标签.  还可以用计算属性computed来代替v-if   (`v-for="item in list"`  在计算属性中写`list(){}`).  计算属性可以先过滤掉不需要的数据,剩下需要的数据再利用v-for渲染.

## **webpack打包原理**

webpack是把项目当作一个整体，通过给定的一个主文件，webpack将从这个主文件开始找到你项目当中的所有依赖的文件，使用loader来处理它们，最后打包成一个或多个浏览器可识别的bundle.js文件.通过代码分割成单元片段并按需加载.

**关于核心思想**:1.一切皆模块---所有文件都可以视作模块,意味着可以将业务分割成更多单元片段,达到复用目的;2.按需加载---利用许多特性来分割代码生成多个bundle.js文件,以实现异步加载.

关于文件管理:每个文件都是一个资源,可以用require/import导入js;每个文件会把自己依赖的资源全部打包在一起,一个资源引用多次的话只打包一份;对于多个入口的情况,其实就是分别独立的执行单个入口情况,每个入口文件不相干.

**loader**是webpack最重要的部分之一，通过使用不同的Loader，我们能够调用外部的脚本或者工具，实现对不同格式文件的处理，loader需要在webpack.config.js里边单独用module进行配置.

**打包后文件过大怎么优化**:vue项目用vue-cli执行命令:`npm run build --report` 来进行打包分析,看到项目中的依赖占比后抽出占比较大的以来,改用**CDN**的方式导入;还可以路由懒加载来分割文件减小体积;后端用文件压缩.

**首页加载速度优化** **:因为打包时，第三方依赖都会被打包到`vender.js`中,很集中，如果这个文件很大，那么首屏加载速度肯定会被拖慢。  怎么优化?   针对这个问题我们的解决方案是,用文档的CDN文件代替,直接在index.HTML中引入依赖库js文件.把第三方依赖文件从打包文件中去掉,通过inport引入的也去掉.   同时去除闲置依赖包,路由懒加载,图片资源也进行压缩.

**优化有哪些方面**

**图片优化**:改变图片的格式;减少像素点和每个像素点能够显示的颜色来压缩图片大小. 

**渲染优化:**客户端渲染-----在客户端渲染模式下，服务端会把渲染需要的静态文件发送给客户端，客户端加载过来之后，自己在浏览器里跑一遍 JS，根据 JS 的运行结果，生成相应的 DOM。页面上呈现的内容，你在 html 源文件里里找不到,这是它的特点。  服务端渲染-----是当用户第一次请求页面时，由服务器把需要的组件或页面渲染成HTML字符串，然后把它返回给客户端。页面上呈现的内容，我们在 html 源文件里也能找到。服务端渲染解决了一个非常关键的性能问题——首屏加载速度过慢，也解决了SEO搜索引擎的问题。

**浏览器缓存策略:** 详情见强制缓存和协商缓存

**加载资源优化**:从输入url到显示页面的过程中,涉及了三大部分---DNS解析,TCP链接,HTTP响应.HTTP请求和响应优化是重点.http优化又分为两方面: 减少请求次数----1.合理的设置http缓存，恰当的缓存设置可以大大减少http请求。要尽可能地让资源能够在缓存中待得更久。2、从设计实现层面简化页面，保持页面简洁、减少资源的使用时是最直接的。3.资源合并与压缩，尽可能的将外部的脚本、样式进行合并，多个合为一个。4、CSS Sprites，合并 CSS图片，减少请求数;   尽量减少单次请求花费的时间.       此外函数防抖和节流也能有效减少损耗,防止出现卡顿.  

**js性能优化**  **:1.-资源加载方面-:合并文件以减少浏览器请求;使用defer和async属性,都是并行下载,区别在于async是下载完后立即执行,defer立即下载延迟执行并且只适用于外部文件.  2.-代码优化-:减少DOM操作,DOM操作最耗性能;减少访问全局变量,因为访问当前作用域外的变量时间会增加. 3.-网络请求-:尽量减少http的请求次数;合理设置http缓存. 4.-使用资源预加载-.

**页面性能优化** **:页面加载有八成的时间都花在了下载页面的组件上。因此改善响应时间最简单的途径就是减少http请求.  比如可以将图片改为精灵图的形式;合并js,css文件以减少请求次数.  再者路由也使用懒加载,非核心代码进行异步加载.还有对代码进行精简,删除冗余的代码.

**CSS优化**:提取通有样式,增强可复用性;使用预处理器或者构建工具(gulp工具可以进行语法检查,自动优雅降级等)

**项目中怎么解决跨域问题**  **:用CORS跨域资源共享.总的来说,使用CORS简单请求非常容易,对于前端来说无需做任何配置,与发送普通ajax请求无异.唯一需要注意的是,如果需要携带cookie信息,就要把withCredentials设置为true,否则不会带cookie信息实现会话共享.如果不需要会话共享的话就可以不用设置.而CORS的配置,完全在于后端,配置起来也比较容易.CORS目前对于大部分浏览器兼容性也比较好.它的优势也比较明显,可以实现任何类型的请求.相较于JSONP跨域只能使用get请求来说,也更加便于我们的使用.

**for的几种用法**: `for...of` 语法遍历的是数组元素的值,适用于遍历数/数组对象/字符串/map/set等拥有迭代器对象的集合,不能遍历对象 ; `for...in` 遍历的是索引,它可以遍历一个普通对象,可以遍历原型以及可枚举属性.

**从输入 URL到加载出页面过程中都发生了什么**:1---输入URL; 2---浏览器查找域名的IP地址3---查找完成之后浏览器向web服务器发送一个HTTP请求;  4---服务器的永久重定向相应;  5---浏览器跟踪重定向地址;  6---服务器处理请求;  7---服务器返回一个http响应。 8---浏览器显示HTML;  9---浏览器发送异步请求

# ES6

**模板字符串` 反引号${}反引号 `** :${}中的是变量,用来代替复杂的引号加加号的拼接方法,很方便简洁.

**let和const**:都是声明块级作用域.都不存在变量提升. const声明的变量不能重复赋值(变量指向的内存地址所保存的数据不得改动),let可以.    for循环中使用var声明循环变量时,会跳出循环体污染当前函数.     实际开发中选择let/const/var取决于我们的变量是否需要更新.

**this**:**this永远指向最后调用它的那个对象**,而在箭头函数中的this指向函数定义时的this.,不是执行时的this.  匿名函数this指向window.如果有new关键字,this指向new出来的那个对象;在事件中,this指向触发这个事件的对象,但是在IE中的attachEvent中的this总是指向全局对象window.

 **改变this指向**:使用ES6箭头函数;在函数内部使用`_this=this`;使用apply,call,bind;new实例化一个对象.   apply和call的区别是---apply传入的是参数列表,call是参数数组.

**箭头函数**:没有this.没有原型.不能使用new.

**尾调用优化**:在函数return的时候调用一个新的函数. 由于尾调用的实现需要存储到内存中,在一个循环中如果存在尾调用,内存可能溢出.  es6会帮你做好优化工作,只要这个函数不是闭包;尾调用是函数最后一条语句;尾调用的结果最为函数返回.  实际用于递归函数优化.

**Object.assign(),深浅拷贝**: 拷贝时只拷贝一层,也就是说拷贝的只是对象的引用,如果你改了其中一个数据,那么原对象和拷贝对象都会改变,使用Object.assign()就可以;深拷贝拷贝的是每一层的数据,所以拷贝对象是完全独立出来的,用`JSON.parse(JSON.stringify(obj))`,先将对象转为json字符串,再转回json对象.

**用JSON.parse(JSON.stringify(obj))的弊端**: 1.时间对象这样转之后,时间只是字符串形式 ; 2.正则对象和Error对象序列化(stringify)的结果只会得到空对象 ; 3.如果有函数或者undefined,序列化之后会把函数或undefined丢失 ; 4.对象中存在循环引用的情况也无法正确实现深拷贝.  等等...  在这些情况下可以用js拷贝,外层拷贝完了之后再用递归方式对里层进行拷贝.

**Map和Set**: map和set都是集合,但是set常用来检查对象中是否存在某个键名,map被用来获取已存信息.  Set是有序列表,含有相互独立的非重复值.

**数组新方法**: `forEach()`,`map()`,`filter()`,`every()`,`find()`,`some()`,`reduce()`.

**扩展运算符**:将一个数组转为用逗号分隔的参数序列还可以将字符串转为真正的数组.

**addEventListener()**:此方法设定一个事件监听器,当某一事件发生通过设定的参数执行操作.参数1-坚挺的事件(必须);参数2-触发后调用的函数(必须).

**cookies，sessionStorage 和 localStorage 的区别**:`cookie`是网站为了标示用户身份而储存在用户本地终端上的数据（通常经过加密）,它的数据始终在同源的http请求中携带，会在浏览器和服务器间来回传递;而`sessionStorage`和`localStorage`不会自动把数据发给服务器，仅在本地保存.      在数据大小方面也有差别:`cookie`不能超过4k,其他两个有5M左右,比cookie大得多.      `Cookie`可以设置数据存储时间,`localStorage`长期存储数据,关闭浏览器数据不丢失;`sessionStorage`关闭浏览器后数据自动删除.

**Promise**:三个状态---pending[待定]初始状态;fulfilled[实现]操作成功
;rejected[被否决]操作失败.     promise的方法:   `.then()`   `.catch()`   `.all()`把多个promise实例包装成一个       `.race()`也是把多个promise实例包装成一个       `.resolve()`将现有对象转为promise对象       `.reject()`返回一个状态为reject的实例      `.finally()`不管promise状态如何都会执行操作         promise的应用一般与generator/yield结合,而async又是generator的语法糖

**Async/await**:`Async/await`其实是`generator/yield`的语法糖.generator函数从内部向外返回数据,并且会分段执行,yield语句就是就是暂停执行的标记.generator函数的特点是分段执行可以暂停;可以控制阶段和每个阶段的返回值;可以知道是否进行到结尾.async函数的返回值总是返回promise实例,await用在async函数中,后面是promise实例,如果不是则会用promise.resolve()转为实例,所以就有了比较精简的写法.await左边的变量就是promise成功后的resolve数据.

**px和rem和em的区别**:都是长度单位,但是px值是固定的便于计算;em值不固定,是相对单位,会继承父级元素的字体大小。比如字体默认16px,那么1em=16px。    Em和rem区别在于使用rem为元素设定字体大小时，仍然是相对大小，但相对的只是HTML根元素。通过它既可以做到只修改根元素就成比例地调整所有字体大小，又可以避免字体大小逐层复合的连锁反应。

# HTML+CSS

**HTML中导入css文件**:行内样式,内部样式表,外部样式表.    其中外部样式表有两种导入方式---链接式(`<link href="css文件路径"/>`)和导入式(`<style type="text/css">@import url("css文件路径")</style>`)

**BFC布局规则**:全称是块格式化上下文。可以形成一个独立容器,不受外界影响,从而解决一些布局问题.        BFC的触发条件也挺多的,比如说float的值不为none的时候;position的值为fixed或者absolute的时候。display,overflow

同一个BFC下外边距会发生折叠。如果想要避免外边距的重叠，可以将其放在不同的 BFC 容器中。

规则:1.内部的块级元素会在垂直方向，一个接一个地放置；  2.块级元素垂直方向的距离由margin决定。属于同一个BFC的两个相邻的块级元素会发生margin合并，不属于同一个BFC的两个相邻的块级元素不会发生margin合并；  3.每个元素的margin box的左边，与包含border box的左边相接触（对于从左往右的格式化，否则相反）。即使存在浮动也是如此；  4.BFC的区域不会与float box重叠；  5.BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会在布局上影响到外面的元素；外面的元素也不会影响到容器里面的子元素,并且 BFC 具有普通容器所没有的一些特性；  6.计算BFC的高度时，浮动元素也参与计算

**box-sizing有两个值**:center-box(标准模型),border-box(怪异模型)

**flex及适用场景**:Css3新功能,用来为盒装模型提供最大的灵活性,任何一个容器都可以指定为flex布局.通过给父盒添加flex来控制子盒的位置和排列方式,flex中默认子元素不换行.更适用于移动端布局.

如果要水平垂直居中,同时设置主轴和侧轴的居中.

**父盒主要属性**有:flex-direction决定主轴的方向(横向或纵向),剩下的一个就是侧轴; justify-content项目在主轴上的对齐方式(center居中对齐,space-between两边对齐,space-around项目两侧间隔相等);align-items项目在交叉轴(侧轴)上如何对齐.

**子盒主要属性**:flex属性定义子项目分配剩余空间,用flex来表示占多少份数,默认值0,还可以写百分比,表示每个子项目占父级宽度的百分比.如果要平均分配空间就能写成flex:1;

**实现水平垂直居中**: (用哪种布局方式实现取决于父子元素的宽高是否固定)

如果父子元素宽高都固定的话,用relative和absolute;如果父元素和子元素宽高都不固定的话,用flex. justify-content:center;align-item:center;  或者relative和absolute+transform:translate(-50%,-50%); .

**谈谈你对闭包的理解**:闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量,利用闭包可以突破作用链域，将函数内部的变量和方法传递到外部。    函数内部可以直接读取全局变量，但在函数外部无法读取到内部的变量，（定义在一个函数内部的函数），闭包是反垃圾回收机制的，这就是所谓的作用链域，闭包的特性是私有性，这种特性是闭包得变量存在内存中，内存消耗很大，造成网页性能问题，（在ie中会造成内存泄漏问题）在退出函数之前将全部变量清除。私有化变量

## **函数防抖和节流**

**防抖**:防抖就是指触发事件后在n秒内函数只能执行一次,如果在n秒内又触发了事件,则会重新计算函数执行时间. 例如我们想监听搜索框,用户快速输入一连串字符就会瞬间触发十次请求,但是我们想要的是停止输入再触发请求.

**节流**:节流就是指连续触发事件但是在n秒中只执行一次函数.节流会稀释函数的执行频率,避免在间隔内函数的过多执行. 例如滚动浏览器滚动条的时候,更新页面的布局内容.

**Js的继承方式有哪些**

**原型链继承**:将父类的实例作为子类的原型,但是引用属性被所有实例共享;   **构造函数继承**:使用父类的构造函数来增强子类实例,等于是赋值父类的实例属性给子类,避免了实例共享但是每次创建实例都会创建一次方法;   **组合继承**:原型链继承和构造函数继承的组合.通过调用父类构造,继承父类的属性并保留传参,然后通过将父类实例作为子类原型,实现函数的复用.是最常用的继承方式 ;   **寄生组合继承**:通过寄生的方式砍掉父类的实例属性,这样在两次调用父类构造函数的时候就不会两次初始化方法属性,与此同时原型链保持不变. 它应该是引用类型最理想的继承方式.

**原型和原型链**

**原型**的作用是数据共享,节约内存空间.也能实现继承.它把所有对象公用的属性全部放在堆内存的一个实例对象中,然后让每一个proto对象存储这个地址.这个共用属性就是原型.

**原型链**就是在调用某个对象的属性或方法时，js引擎会优先在该对象自身上查找该属性或方法，如果没有便去该对象的构造函数中去查找，如此逐级递归的查找，直到原型链的顶端object的原型上还没有找到想要的属性和方法的话,就会返回undefined.

## **js数组方法**

**Array.from()** :用于将类数组对象和可遍历的对象(包括Map和Set)转换为真正的数组.

**Array.of()** :将一组值转换成数组,基本可以替代Array(),不存在参数不同导致的重载.

**filter()** :用来过滤数组中不满足条件的元素,把满足条件的元素放到新的数组里,不改变原数组.

**map()** :主要用来创建新数组,参数和forEach相同.但是使用map遍历数组,会返回一个新的数组,不改变原数组的内容.也可以map(string) .

**forEach()**:会遍历数组,循环体内内有返回值;循环不会改变原来数组内容.有三个参数--当前元素,当前元素的索引,当前元素所属数组. 他有一个问题就是不能跳出整个循环.  对空数组不会调用函数.

**some()**:遍历数组,根据循环体内条件去判断,只要有一个是true就停止循环.

**every()**:和some不同的是,它的判断如果每一项都是true才会返回true.

# 兼容相关问题

**常见浏览器极其对应内核**:  IE---IE内核(Trident) ; Firfox---Firfox内核(Gecko) ; Chrome---Chrome内核(Blink) ; Safari---Webkit 内核 ; QQ浏览器,搜狗,遨游---IE内核(Trident)(兼容模式)+Chrome内核(Chromium)(高速模式)

**浏览器内核是干嘛的**:浏览器内核就是负责读取网页内容，整理讯息，计算网页的显示方式并显示页面.

**兼容问题?** :怎么处理兼容性问题?首先要以最大程度完善设计稿为基础,再考虑兼容性,有两种处理观点:

**渐进增强**：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。**优雅降级**：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。     **区别**：优雅降级是从复杂的现状开始，并试图减少用户体验的供给，而渐进增强则是从一个非常基础的、能够起作用的版本开始，并不断扩充,以便于适应未来环境。降级意味着往回看,增强意味着朝前看,同时让根基处于安全地带.    **Hack写法:**_color(IE6生效);*color(IE7生效).     **Css Reset**:将浏览器的默认样式全部去掉,重新定义标签样式,覆盖浏览器的css默认属性.     **条件注释**:可以用来向IE提供隐藏代码.

**常见的js兼容问题**:  **事件绑定**:标准的事件绑定方法函数为`addEventListener()`，但IE下是`attachEvent()`.IE里事件对象仅存在于window.event参数中。(event,target解决方法,用三元表达式) .   获取目标元素的方法不同，标准浏览器是event.target，而IE下是event.srcElement.  事件必须以ontype的方式命名.比如:onclick而不是click.

**常见的浏览器兼容问题**

1---浏览器默认的内外边距不一样，所以用通用选择器*设置margin和padding来设置。2---块标签设置浮动后，有设置margin的情况下，在ie6下的margin比别的浏览器大。解决方案--在float的标签样式控制中加入 display:inline;转化为行内属性。3---img标签会有默认的间距，需要用浮动去设置。4---Firefox中的点击事件和滚动事件需要加（event）来兼容。5---div里的内容，ie默认为居中，firefox默认为左对齐，需要用margin:0px auto来调节。6---css3的动画效果不兼容ie8以下。需要使用js去写动画。7---ie6的双倍边距，比如设置了margin:10px,ie6中默认为20px，需要使用display:inline,block。8---上下margin重叠:因为浏览器会识别较大的那个值,所以只需设置一个值。9---若需给 a 标签内内容加上样式, 需要设置 display: block;(常见于导航标签)。10---特殊样式的兼容度,比如透明度,圆角等。

**meta标签**:能解决很多兼容问题. name属性定义文档描述,关键词,作者等.  content属性描述文档中的元数据.   http-equiv属性向浏览器传递信息.    为移动端添加viewport(视口):  `<meta name=”viewport” content=”initial-scale=1, maximum-scale=3, minimum-scale=1, user-scalable=no”>`  不能放大缩小屏幕叭叭叭的

避免IE使用兼容模式:`<meta http-equiv=”X-UA-Compatible” content=”IE=edge”> `  .

# 小程序相关问题

在小程序中是通过`App()`来注册一个小程序,`Page()`注册一个页面.

**vx-if和hidden**:相当于vue中的`v-if`和`v-show` . 如果需要频繁切换就用hidden.  hidden和v-show都有更高的初始渲染消耗,v-if有更高的切换消耗.

**小程序全局文件的生命周期** :全局文件生命周期一共有四个,在app.js中调用--- `onLaunch()` 监听小程序初始化.当小程序初始化完成时,会触发(全局只触发一次);  `onShow()` 监听小程序显示.当小程序启动,或从后台进入前台显示，会触发; `onHide()` 监听小程序隐藏.当小程序从前台进入后台,会触发;   `onError()` 错误监听函数.当小程序发生脚本错误,或者 api 调用失败时，会触发 onError 并带上错误信息.

**每个页面的生命周期函数** :页面周期函数一共有五个--- `onLoad()` 页面加载时触发.全局只会调用一次.在该周期内可获取当前页面路径的参数 ; `onShow()` 页面显示时触发或者切入前台时触发.也就是在该周期内可以获取请求数据 ; `onReady()` 页面初次渲染完成时触发.只会调用一次，代表页面已经可以和视图层进行交互 ; `onHide()` 页面隐藏或者切入后台时触发 ; `onUnload()` 页面卸载时触发 .    `onShow()`和`onHide()`常用.

**webview页面怎么跳转到小程序主页面**:通过`switchTab` .

**怎么封装微信小程序的数据请求**: 先将所有接口放在统一的js文件中导出;然后在app.js中创建 封装请求数据 的方法;最后在子页面中调用封装的方法来请求数据.

**bindtap和catchtap的区别** : 首先他们同为点击事件函数,在作用上他们是相同的.不同的是`bindtap`不会阻止冒泡事件,而`catchtap`是会阻止冒泡的.

**怎么传参** : 

**setData()** : 用于将数据从逻辑层(js)发送到视图层(html)(异步),同时改变对应的 this.data 的值（同步）。两个参数, `data`是这次要改变的数据,是个对象;`callback`是更新完毕之后的回调函数,不是必须的.     如果在`onReady()`中调用setData（）方法，那么通过这个方法设置的值只能刷新一次，若需要再次刷新，需要清除缓存.

**setData()的使用注意点** : 调用一次setData的开销会比较大.因为每次调用它都是逻辑层向视图层的通讯,通讯时会通过`native`层,并且视图层收到通讯后需要重新渲染出来.   在这种情况下需要注意减少setData的数据量;合并请求,减少通讯次数;尽量用它进行局部刷新.

**性能的提升(加载速度)** : 分为两个方面来看,加载性能和渲染性能.     针对这个问题我的解决方案是:加载上首先要控制包的大小,压缩代码,清理无用的代码;控制图片大小,有必要放在CDN上.再一个就是在异步请求的时候,在`onLoad()`页面加载时就发起请求,把请求结果放在缓存中.   渲染方面首先注意`setData`的数据量,做到请求返回的数据都是需要用到的数据;并且减少setData的请求通讯次数;再一个就是离开页面时，在生命周期 `onHide()`内清空定时器,删除冗余的数据,否则会影响当前页面的性能.

**怎么发送请求**:在App.js中定义请求地址，在index.js中通过wx.request进行请求发送，参数在data中。 但是request请求如果并发数超过10会报错，解决这个并发数问题用Promise解决


































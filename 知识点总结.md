# Vue

**自定义指令**:是在仍然需要对DOM进行底层操作时.样式什么的不需要插入到DOM树中就可以渲染到页面上,但是DOM行为不行.   分全局指令`directive`和私有指令`directives` .

`Vue.directive('指令名称',{bind:function(el,binding){}})`    

简写式-包含bind和update钩子函数:`'指令名称':function(el,binding){}`

**路由懒加载**:`const home = () => import("地址")` 在router.js中导入

**vue.js的两个核心是什么**:数据驱动,组件系统.

**npm run build(打包)带来的问题**:都是路径格式的问题,打开`webpack.config.js`文件,修改assetsPublicPath为相对路径.

插值表达式中可以放入简单的js表达式:`{{msg.split()}}` .

**监听机制**:

- **计算属性computed**.本质上是vue实例对象上的一个属性. 会自动监测数据源的改变：只有数据源发生变化才会重新执行计算属性，否则会返回缓存中的上次的计算结果。**计算属性的监听适用于多对一的场景，即某个组件内的一个数据(add)会受多个数据(num1,num2)的影响(比如add=num1+num2)(多个影响一个)。**不限制响应式依赖(就是data中的数据,在computed里是this.msg)的个数和数据类型,会多个同时监听 .    比methods先执行,要写在methods前面.   不能用箭头函数,会使指向混乱.    默认深度监听.   其中的函数必须用return返回.    使用情景:例如商品结算,计算总值时.
- **监听器watch**:**`watch`的监听适用于一对多(一个影响多个)的场景**，即某个组件内的一个数据的改变会影响其他多个数据。  设置`deep:true`或者直接点(.)到想监听的数据上,才会深度监听.    适用场景:例如搜索框.

**MVVM和MVC架构模式的区别**:这些架构模式的目的都只有两个:1.怎么管理响应用户操作的业务逻辑;2.View怎么同步Model的变更.

**现在常用的是服务端的MVC**,服务端接收到来自客户端的请求后,通过路由规则把这个请求交由给特定的Controller进行处理，Controller执行相应的业务逻辑，对数据库数据（Model）进行操作，然后用数据去渲染特定的模版，返回给客户端。这个MVC中的V指的就是前端.     **在vue中应用的模式是MVVM**.在MVVM中View和ViewModel相互依赖,ViewModel依赖Model.VM中有一个叫Binder的东西,它的作用是你只需要在view模板语法中,指令式的声明 显示内容是和Model中哪部分数据绑定的,然后当View和Model进行更新的时候,Binder就会自动进行双向数据绑定,自动化了View和Model的同步逻辑.这种模式的优点是低耦合,可测试(针对VM对界面进行测试),可重用,可以进行独立开发(独立开发业务逻辑和数据,独立开发界面设计).

(问到就说)还知道MVP模式,MVVM是由MVP演化而来,MVP没有双向绑定.

**观察者模式又叫发布-订阅模式**.定义**对象间一种一对多的关系**,当一个对象的状态发生改变时,所有依赖于它的对象都会得到通知和更新.   对象订阅(观察者)事件并在发生时得到通知

**Vue双向绑定原理**: 核心是 `Object.defineProperty()`方法,采用观察者模式,主要通过4个步骤来实现数据双向绑定:实现一个监听器 Observer---实现一个解析器 Compile---实现一个订阅者 Watcher---实现一个订阅器 Dep . 剩下的我记不太清了我只会用.

**data为什么必须是函数**:因为如果是对象的话,data属性值都会在一个共有的数据空间中,各个组件中的data值就会相互影响.如果是函数,那么每个data的返回值都有独立空间.

**key的作用**:key 因为key值是唯一的不变的,除了解决list渲染过程中一些隐蔽的 bug，提高渲染效率，以及在使用相同标签名元素的过渡切换时区分节点以外， **最主要的用途还是在 diff 算法中** 。可以高效的更新虚拟DOM. 在patch过程中通过key精准判断是否同一个节点,使整个patch的过程减少DOM操作量,提高性能.

**虚拟DOM的作用**:通过比对并局部更新DOM,以达到性能优化的目的.

**diff算法**:diff的过程就是调用名为`patch`的函数，比较新旧节点，一边比较一边给真实的DOM打补丁。     当数据发生改变时，set方法会让调用`Dep.notify`通知所有订阅者Watcher，订阅者就会调用`patch`给真实的DOM打补丁，更新相应的视图。

**父给子传值**:父组件中通过绑定属性`v-bind:传递名称 = '需要传递的值'`,子组件中，通过`props[]`来接收从父组件传过来的值，接受到的值就可在子组件的template中使用。

**子给父传值**:子组件给需要传递的值绑定事件,然后在methods中用`this.$emit(组件方法名,传递的数据)` .在父组件方法中引入子组件的自定义事件,完成接收.

**非父子传值**:建立一个公共的js文件,在需要接受的地方用bus.$on接受消息.

大型项目不适合用父子组件传值,耦合太强,要用vuex.

**data和props的区别**:data可读可写,数据是本身就私有的,比如axios请求回来的数据就可以放到data中;props不可更改,数据都是通过父组件传递过来的.

**vuex状态管理模式**:放在store文件夹中.挂载到实例中(main.js).有四个部分:state--包含vuex中的各种状态,getter---类似于计算属性,mutation---方法,改变store中状态的执行者,只能是同步操作;action---包含异步操作的方法.  当项目过于庞大状态非常多时,可以采用模块化管理模式,也就是采用Models.

**生命周期**:Vue 实例从创建到销毁的过程，就是生命周期。  一共有八个阶段--创建前/后,挂载前/后,更新前/后(beforeUpdate/updated),销毁前/后(beforeDestroy/distroy).    它的作用是在生命周期中有多个事件钩子，让我们在控制整个Vue实例的过程时更容易形成好的逻辑。 第一次页面加载会触发beforeCreate,created;beforeMount, mounted.   DOM渲染在mounted中就已经完成了 . 

虚拟DOM重新渲染和打补丁在beforeUpdate和updated之间进行.  `created`时完成数据观测,data和methods初始化完成;`mounted`时完成把模板中的html渲染到html页面中。此过程中进行ajax交互。

**事件循环event loop**:先执行同步任务,然后执行微任务队列,再执行宏任务队列(宏任务每次执行一个,然后在执行微任务,执行完所有微任务再执行下一个宏任务).

**router-link(命令路线)&router-view(命令视图)**: <router-link  to:"目标路由">--链接到目标路由;router-view相当于一个占位符,展示对应的视图.

**nextTick()**:当数据更新了，在dom中渲染后，自动执行该函数.

**v-if和v-for的使用方式**  **:同时使用时v-for的优先级高于v-if, 每一次都需要遍历整个数组，将会影响速度,所以不推荐同时使用.       如果非要同时使用建议把v-if放在外层标签.  还可以用计算属性computed来代替v-if   (`v-for="item in list"`  在计算属性中写`list(){}`).  计算属性可以先过滤掉不需要的数据,剩下需要的数据再利用v-for渲染.

**打包后文件过大怎么优化**:vue项目用vue-cli执行命令:`npm run build --report` 来进行打包分析,看到项目中的依赖占比后抽出占比较大的以来,改用**CDN**的方式导入;还可以路由懒加载来分割文件减小体积;后端用文件压缩.

**首页加载速度优化** **:因为打包时，第三方依赖都会被打包到`vender.js`中,很集中，如果这个文件很大，那么首屏加载速度肯定会被拖慢。  怎么优化?   针对这个问题我们的解决方案是,用文档的CDN文件代替,直接在index.HTML中引入依赖库js文件.把第三方依赖文件从打包文件中去掉,通过inport引入的也去掉.   同时去除闲置依赖包,路由懒加载,图片资源也进行压缩.

**js性能优化**  **:1.-资源加载方面-:合并文件以减少浏览器请求;使用defer和async属性,都是并行下载,区别在于async是下载完后立即执行,defer立即下载延迟执行并且只适用于外部文件.  2.-代码优化-:减少DOM操作,DOM操作最耗性能;减少访问全局变量,因为访问当前作用域外的变量时间会增加. 3.-网络请求-:尽量减少http的请求次数;合理设置http缓存. 4.-使用资源预加载-.

**页面性能优化** **:页面加载有八成的时间都花在了下载页面的组件上。因此改善响应时间最简单的途径就是减少http请求.  比如可以将图片改为精灵图的形式;合并js,css文件以减少请求次数.  再者路由也使用懒加载,非核心代码进行异步加载.还有对代码进行精简,删除冗余的代码.

**CSS优化**:提取通有样式,增强可复用性;使用预处理器或者构建工具(gulp工具可以进行语法检查,自动优雅降级等)

**项目中怎么解决跨域问题**  **:用CORS跨域资源共享.总的来说,使用CORS简单请求非常容易,对于前端来说无需做任何配置,与发送普通ajax请求无异.唯一需要注意的是,如果需要携带cookie信息,就要把withCredentials设置为true,否则不会带cookie信息实现会话共享.如果不需要会话共享的话就可以不用设置.而CORS的配置,完全在于后端,配置起来也比较容易.CORS目前对于大部分浏览器兼容性也比较好.它的优势也比较明显,可以实现任何类型的请求.相较于JSONP跨域只能使用get请求来说,也更加便于我们的使用.

**for的几种用法**: `for...of` 语法遍历的是数组元素的值,适用于遍历数/数组对象/字符串/map/set等拥有迭代器对象的集合,不能遍历对象 ; `for...in` 遍历的是索引,它可以遍历一个普通对象,可以遍历原型以及可枚举属性.

# ES6

**模板字符串` 反引号${}反引号 `** :${}中的是变量,用来代替复杂的引号加加号的拼接方法,很方便简洁.

**let和const**:都是声明块级作用域.都不存在变量提升. const声明的变量不能重复赋值(变量指向的内存地址所保存的数据不得改动),let可以.    for循环中使用var声明循环变量时,会跳出循环体污染当前函数.     实际开发中选择let/const/var取决于我们的变量是否需要更新.

**this**:**this永远指向最后调用它的那个对象**,而在箭头函数中的this指向函数定义时的this.,不是执行时的this.  匿名函数this指向window.

 **改变this指向**:使用ES6箭头函数;在函数内部使用`_this=this`;使用apply,call,bind;new实例化一个对象.   apply和call的区别是---apply传入的是参数列表,call是参数数组.

**箭头函数**:没有this.没有原型.不能使用new.

**尾调用优化**:在函数return的时候调用一个新的函数. 由于尾调用的实现需要存储到内存中,在一个循环中如果存在尾调用,内存可能溢出.  es6会帮你做好优化工作,只要这个函数不是闭包;尾调用是函数最后一条语句;尾调用的结果最为函数返回.  实际用于递归函数优化.

**Object.assign(),深浅拷贝**: 拷贝时只拷贝一层,也就是说拷贝的只是对象的引用,如果你改了其中一个数据,那么原对象和拷贝对象都会改变,使用Object.assign()就可以;深拷贝拷贝的是每一层的数据,所以拷贝对象是完全独立出来的,用`JSON.parse(JSON.stringify(obj))`,先将对象转为json字符串,再转回json对象.

**用JSON.parse(JSON.stringify(obj))的弊端**: 1.时间对象这样转之后,时间只是字符串形式 ; 2.正则对象和Error对象序列化(stringify)的结果只会得到空对象 ; 3.如果有函数或者undefined,序列化之后会把函数或undefined丢失 ; 4.对象中存在循环引用的情况也无法正确实现深拷贝.  等等...  在这些情况下可以用js拷贝,外层拷贝完了之后再用递归方式对里层进行拷贝.

**Map和Set**: map和set都是集合,但是set常用来检查对象中是否存在某个键名,map被用来获取已存信息.  Set是有序列表,含有相互独立的非重复值.

**数组新方法**: `forEach()`,`map()`,`filter()`,`every()`,`find()`,`some()`,`reduce()`.

**扩展运算符**:将一个数组转为用逗号分隔的参数序列还可以将字符串转为真正的数组.

**addEventListener()**:此方法设定一个事件监听器,当某一事件发生通过设定的参数执行操作.参数1-坚挺的事件(必须);参数2-触发后调用的函数(必须).

**cookies，sessionStorage 和 localStorage 的区别**:`cookie`是网站为了标示用户身份而储存在用户本地终端上的数据（通常经过加密）,它的数据始终在同源的http请求中携带，会在浏览器和服务器间来回传递;而`sessionStorage`和`localStorage`不会自动把数据发给服务器，仅在本地保存.      在数据大小方面也有差别:`cookie`不能超过4k,其他两个有好几兆,比cookie大得多.      `Cookie`可以设置数据存储时间,`localStorage`长期存储数据,关闭浏览器数据不丢失;`sessionStorage`关闭浏览器后数据自动删除.

**Promise**:三个状态---pending[待定]初始状态;fulfilled[实现]操作成功
;rejected[被否决]操作失败.     promise的方法:   `.then()`   `.catch()`   `.all()`把多个promise实例包装成一个       `.race()`也是把多个promise实例包装成一个       `.resolve()`将现有对象转为promise对象       `.reject()`返回一个状态为reject的实例      `.finally()`不管promise状态如何都会执行操作         promise的应用一般与generator/yield结合,而async又是generator的语法糖

**Async/await**:`Async/await`其实是`generator/yield`的语法糖.generator函数从内部向外返回数据,并且会分段执行,yield语句就是就是暂停执行的标记.generator函数的特点是分段执行可以暂停;可以控制阶段和每个阶段的返回值;可以知道是否进行到结尾.async函数的返回值总是返回promise实例,await用在async函数中,后面是promise实例,如果不是则会用promise.resolve()转为实例,所以就有了比较精简的写法.await左边的变量就是promise成功后的resolve数据.

**px和rem和em的区别**:都是长度单位,但是px值是固定的便于计算;em值不固定,是相对单位,会继承父级元素的字体大小。比如字体默认16px,那么1em=16px。    Em和rem区别在于使用rem为元素设定字体大小时，仍然是相对大小，但相对的只是HTML根元素。通过它既可以做到只修改根元素就成比例地调整所有字体大小，又可以避免字体大小逐层复合的连锁反应。



# HTML+CSS

**HTML中导入css文件**:行内样式,内部样式表,外部样式表.    其中外部样式表有两种导入方式---链接式(`<link href="css文件路径"/>`)和导入式(`<style type="text/css">@import url("css文件路径")</style>`)

**BFC布局规则**:全称是块格式化上下文。可以形成一个独立容器,不受外界影响,从而解决一些布局问题.        BFC的触发条件也挺多的,比如说float的值不为none的时候;position的值为fixed或者absolute的时候。display,overflow

同一个BFC下外边距会发生折叠。如果想要避免外边距的重叠，可以将其放在不同的 BFC 容器中。

规则:1.内部的块级元素会在垂直方向，一个接一个地放置；  2.块级元素垂直方向的距离由margin决定。属于同一个BFC的两个相邻的块级元素会发生margin合并，不属于同一个BFC的两个相邻的块级元素不会发生margin合并；  3.每个元素的margin box的左边，与包含border box的左边相接触（对于从左往右的格式化，否则相反）。即使存在浮动也是如此；  4.BFC的区域不会与float box重叠；  5.BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会在布局上影响到外面的元素；外面的元素也不会影响到容器里面的子元素,并且 BFC 具有普通容器所没有的一些特性；  6.计算BFC的高度时，浮动元素也参与计算

**box-sizing有两个值**:center-box(标准模型),border-box(怪异模型)

**flex及适用场景**:Css3新功能,用来为盒装模型提供最大的灵活性,任何一个容器都可以指定为flex布局.通过给父盒添加flex来控制子盒的位置和排列方式,flex中默认子元素不换行.更适用于移动端布局.

如果要水平垂直居中,同时设置主轴和侧轴的居中.

**父盒主要属性**有:flex-direction决定主轴的方向(横向或纵向),剩下的一个就是侧轴; justify-content项目在主轴上的对齐方式(center居中对齐,space-between两边对齐,space-around项目两侧间隔相等);align-items项目在交叉轴(侧轴)上如何对齐.

**子盒主要属性**:flex属性定义子项目分配剩余空间,用flex来表示占多少份数,默认值0,还可以写百分比,表示每个子项目占父级宽度的百分比.如果要平均分配空间就能写成flex:1;

# 兼容相关问题

**常见浏览器极其对应内核**:  IE---IE内核(Trident) ; Firfox---Firfox内核(Gecko) ; Chrome---Chrome内核(Blink) ; Safari---Webkit 内核 ; QQ浏览器,搜狗,遨游---IE内核(Trident)(兼容模式)+Chrome内核(Chromium)(高速模式)

**浏览器内核是干嘛的**:浏览器内核就是负责读取网页内容，整理讯息，计算网页的显示方式并显示页面.

**兼容问题?** :怎么处理兼容性问题?首先要以最大程度完善设计稿为基础,再考虑兼容性,有两种处理观点:

**渐进增强**：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。**优雅降级**：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。     **区别**：优雅降级是从复杂的现状开始，并试图减少用户体验的供给，而渐进增强则是从一个非常基础的、能够起作用的版本开始，并不断扩充,以便于适应未来环境。降级意味着往回看,增强意味着朝前看,同时让根基处于安全地带.    **Hack写法:**_color(IE6生效);*color(IE7生效).     **Css Reset**:将浏览器的默认样式全部去掉,重新定义标签样式,覆盖浏览器的css默认属性.     **条件注释**:可以用来向IE提供隐藏代码.

**常见的兼容问题**: 默认样式存在差异:直接*{margin:0;padding:0;}  ;  **事件绑定**:标准的事件绑定方法函数为`addEventListener()`，但IE下是`attachEvent()`.IE里事件对象仅存在于window.event参数中。(event,target解决方法,用三元表达式) .   获取目标元素的方法不同，标准浏览器是event.target，而IE下是event.srcElement.  事件必须以ontype的方式命名.比如:onclick而不是click.

**常见的浏览器兼容问题**:1. 块属性标签float后，又有横向的margin情况下，在[IE6](http://xiazai.zol.com.cn/detail/11/102978.shtml)显示margin比设置的大:解决方案--在float的标签样式控制中加入 display:inline;转化为行内属性 ; 2.图片默认有间距:使用float布局 ; 3.若需给 a 标签内内容加上样式, 需要设置 display: block;(常见于导航标签) ; 4.设置较小高度标签(一般小于10px),在IE6，IE7，遨游中高度超出自己设置高度:给超出高度的标签设置overflow:hidden;或者设置行高line-height 小于你设置的高度。5.特殊样式的兼容度,比如透明度,圆角等.  6.上下margin重叠:因为浏览器会识别较大的那个值,所以只需设置一个值.

**meta标签**:能解决很多兼容问题. name属性定义文档描述,关键词,作者等.  content属性描述文档中的元数据.   http-equiv属性向浏览器传递信息.    为移动端添加viewport(视口):  `<meta name=”viewport” content=”initial-scale=1, maximum-scale=3, minimum-scale=1, user-scalable=no”>`  不能放大缩小屏幕叭叭叭的

避免IE使用兼容模式:`<meta http-equiv=”X-UA-Compatible” content=”IE=edge”> `  .

# 小程序相关问题

在小程序中是通过`App()`来注册一个小程序,`Page()`注册一个页面.

**vx-if和hidden**:相当于vue中的`v-if`和`v-show` . 如果需要频繁切换就用hidden.  hidden和v-show都有更高的初始渲染消耗,v-if有更高的切换消耗.

**小程序全局文件的生命周期** :全局文件生命周期一共有四个,在app.js中调用--- `onLaunch()` 监听小程序初始化.当小程序初始化完成时,会触发(全局只触发一次);  `onShow()` 监听小程序显示.当小程序启动,或从后台进入前台显示，会触发; `onHide()` 监听小程序隐藏.当小程序从前台进入后台,会触发;   `onError()` 错误监听函数.当小程序发生脚本错误,或者 api 调用失败时，会触发 onError 并带上错误信息.

**每个页面的生命周期函数** :页面周期函数一共有五个--- `onLoad()` 页面加载时触发.全局只会调用一次.在该周期内可获取当前页面路径的参数 ; `onShow()` 页面显示时触发或者切入前台时触发.也就是在该周期内可以获取请求数据 ; `onReady()` 页面初次渲染完成时触发.只会调用一次，代表页面已经可以和视图层进行交互 ; `onHide()` 页面隐藏或者切入后台时触发 ; `onUnload()` 页面卸载时触发 .    `onShow()`和`onHide()`常用.

**webview页面怎么跳转到小程序主页面**:通过`switchTab` .

**怎么封装微信小程序的数据请求**: 先将所有接口放在统一的js文件中导出;然后在app.js中创建 封装请求数据 的方法;最后在子页面中调用封装的方法来请求数据.

**bindtap和catchtap的区别** : 首先他们同为点击事件函数,在作用上他们是相同的.不同的是`bindtap`不会阻止冒泡事件,而`catchtap`是会阻止冒泡的.

**怎么传参** : 

**setData()** : 用于将数据从逻辑层(js)发送到视图层(html)(异步),同时改变对应的 this.data 的值（同步）。两个参数, `data`是这次要改变的数据,是个对象;`callback`是更新完毕之后的回调函数,不是必须的.     如果在`onReady()`中调用setData（）方法，那么通过这个方法设置的值只能刷新一次，若需要再次刷新，需要清除缓存.

**setData()的使用注意点** : 调用一次setData的开销会比较大.因为每次调用它都是逻辑层向视图层的通讯,通讯时会通过`native`层,并且视图层收到通讯后需要重新渲染出来.   在这种情况下需要注意减少setData的数据量;合并请求,减少通讯次数;尽量用它进行局部刷新.

**性能的提升(加载速度)** : 分为两个方面来看,加载性能和渲染性能.     针对这个问题我的解决方案是:加载上首先要控制包的大小,压缩代码,清理无用的代码;控制图片大小,有必要放在CDN上.再一个就是在异步请求的时候,在`onLoad()`页面加载时就发起请求,把请求结果放在缓存中.   渲染方面首先注意`setData`的数据量,做到请求返回的数据都是需要用到的数据;并且减少setData的请求通讯次数;再一个就是离开页面时，在生命周期 `onHide()`内清空定时器,删除冗余的数据,否则会影响当前页面的性能.




































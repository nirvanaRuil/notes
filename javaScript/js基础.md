# 零散 最基础知识

js执行顺序由上到下.

**字面量** :都是一些不可改变的值;可以直接使用,但一般不会这么干.

**变量** :可以用来保存字面量,而且变量的值可以任意改变.在开发中都是用变量去保存字面量.用变量对字面量进行定义.

**声明/定义变量** :用var let const声明.只声明一次. 

**赋值** :只声明没赋值报错undefined.

**标识符** :js中可以自主命名的都可以是标识符.例如-变量名,函数名,属性名.

**标识符规则** :1.可以含有字母,数组,_,$;2.不能以数字开头;3.不能是ES中的关键字或保留字;4.一般都采用驼峰命名法.

**数据类型** :指的就是字面量类型,一共有六种----String 字符串 ;  Number 数值  ;  Boolean  布尔值  ;  Null  空值  ;  Undefined 未定义  ;  Object 对象  .  

**typeof** :检查变量类型.  

**String 字符串** :在js中需要使用引号,不使用就是变量;

**Number 数值**:所有数值都是Number类型,包括整数和浮点数(小数) ; 最大值:Number.MAX_VALUE,返回Infinity,表示正无穷,是一个字面量,typeof返回number ; 最小值:Number.MIN_VALUE ,表示最小正值 ; NaN : 特殊数字,表示Not A Number,typeof返回number , 用isNaN判断是不是数字 ; 整数运算可以基本保证精确 ; 如果进行浮点数运算可能得到不精确结果 ; 不要进行精确度比较高的运算 .

**Boolean  布尔值** :有两个值 true&false,表示逻辑上的真和假 ; typeof返回boolean.

**Null  空值&Undefined 未定义** :Null只有一个值就是null,专门表示一个为空的对象,任何值和NaN做运算结果都是NaN ; typeof返回object . Undefined只有一个值就是undefined , 当声明一个变量但是没有赋值时,值就是undefined; typeof返回undefined.

**强制类型转换** :将一个数据类型强制转换为其他的数据类型 . 主要是指将其他的数据类型转换为String,Number,Boolean . 

**其他数据类型转为String** :方式一 :调用被转换数据类型的`toString()`方法 , 该方法不会影响到原变量,它会将转换的结果返回(返回值) ; null和undefined没有toString()方法 . 方式二 : 调用string()函数 , 将被转换数据类型作为参数传递给函数 ; 此方法中对于Number和Boolean 实际上就是调用toString()方法 . 

**其他数据类型转为Number** :方式一:`a = Number(a)`函数,如果是纯数字的字符串,会直接转为数字 ; 如果含有非数字内容,转换为NaN ; 如果是空串则转换为0 ; 布尔值转数字时,true是1,false是0 ; undefined是NaN .  方式二:专转字符串, parseInt() 将字符串中有效整数取出转为Number ; parseFloat()将字符串中有效小数取出 ; 如果对非字符串类型使用方式二时,会先将其转为字符串然后再用方式二  .   `parseInt(a,16)`中可以传递参数来指定数字的进制 .

**其他数据类型转为Boolean** : Boolean()函数:数字转布尔 , 除了0和NaN,其余都是true.字符串转布尔 , 除了空串其余都是true . null和undefined都是false . **==对象也会转换为true==** .

**运算符** :也叫操作符,可以对一个或多个值进行运算 . 

**算术运算符** :` +  -  *  /  %(取模) `   任何值和字符串做加法运算都会先转为字符串再拼串 . 任何值和NaN运算都是NaN . 任何值做` -  *  /  `运算时都会自动转换为Number  , 可以通过`-0  *1  /1` 将其转换为Number , Number()的简单用法. 

**一元运算符** : 只需一个操作数 .    `+"a"` , "a"前面带个加号可以把任意类型转换为Number. 

**自增自减** : 自增:通过自增可以使变量在自身的基础上增加1;一个变量自增后,原变量的值会立即自增1 . 无论是`++a`还是`a++ ` 都会立即使原变量的值自增1 ,区别在于 `a++`是自增前的值(先输出后自增 ; a++本身是原变量的值,本身计算完了之后就会自增1,再用a就是自增后的值是这个意思) ; `++a`是自增后的值(先自增后输出 ; 是原变量的新值,a++本身是自增1后的值,再用a还是自增后的值) .  `a--`&`--a`和++的用法相同 . 

**逻辑运算符** :  ! 对一个值进行非运算(取反) ,如果是非布尔值,会转换为布尔值后再进行取反 .  &&进行与运算 . ||进行或运算 .  非布尔值会先转为布尔值:&&--都为true,返回后面的;有false返回false .  ||--第一个值是true返回第一个值;第一个是false返回第二个值 . 

**赋值运算符** : = 右侧值赋值给左侧 . a+=1 等价于a=a+1 ; ` +  -  *  /  %`都适用 . 

**关系运算符** : 比较两个值的关系 .   `>`&`<` ; `>=`&`<=`.  如果符号两侧都是字符串,不会将其转换为数字进行比较,而会把字符编码一位一位进行比较 . 

**相等运算符** :  `==`来做相等运算 ,只判断值 ; `===`全等运算符,既判断值又判断数据类型 ; `!==` 不全等,不会自动转换类型 . `null==undefined` , undefined衍生自null,所以值相等 . NaN不和任何值相等,包括自身 .

**三元运算符** : 语法: `条件表达式?语句1:语句2;` , 首先对条件表达式进行求值,如果该值为true执行语句1, false执行语句2 .  非布尔值会先转为布尔值 .

**运算符优先级** :  逗号运算符:分割多个语句,声明多个变量 .   ....太多了自己看表吧~

**编码** : 网页中使用时: `<h1>&#编码</h1>` , 是十进制 .   `\u`编码 .



# 控制语句  基础知识

js中的代码块只有分组作用 .

控制语句可以使程序根据一定条件选择执行.

控制语句有三种:

- 条件判断语句(选择语句)
- 条件分支语句(switch语句)
- 循环语句

## 条件判断语句

可以射在执行某个语句之前进行判断,条件成立才会执行.

### if语句/if..else语句/if..else if语句

语法一:  if语句在执行时会先**对条件表达式进行求值判断** , 如果表达式为true,执行语句 . false不会执行 .    

if(条件表达式){
	语句;
}

语法二:  if...else语句在执行时会先对条件表达式进行求值判断,条件表达式为true执行语句 ; false执行语句二 . 

if(条件表达式){
	语句;
}else{

​	语句二;

}

语法三:  会从上到下依次对条件表达式进行求值判断 . 值为true执行当前语句 , false继续向下判断 .   只会有一个代码块被执行

if(条件表达式){
	语句;
}else if(条件表达式){

​	语句二;

}else if(条件表达式){

​	语句三;

}else{

​	语句四;

}

## 条件分支语句(switch)

```javascript
switch(条件表达式){
​	case 表达式 : alert(" ");
​			 break;
​	case 表达式 : alert(" ");
​			 break;
​	case 表达式 : alert(" ");
​			 break;
​	default:
​			  	 alert(" ");
			 break;
}
```

执行流程:  switch...case...语句在执行时会将case后的表达式的值和switch后的条件表达式**==依次进行全等比较==**  .  结果为true,则从当前case执行代码 ; 结果为false , 继续向下比较 .   所有比较结果都是false时,输出default .

if 和switch 可以互换,功能相等 . 根据实际情况选择 .

## 循环语句

通过循环语句可以反复执行一段代码多次

### while循环/do...while循环

语法:

while(条件表达式){

​	语句;

}

在执行时,先对条件表达式进行求值判断,如果值为true , 执行循环体 . 循环体执行完毕后,继续对表达式进行判断, 如果为false,终止循环 . 

慎用将条件表达式写死的死循环 . 

创建一个循环需要三个条件**:创建初始化变量 ; 循环中设置条件表达式 ; 定义一个更新表达式**,每次更新初始化变量 . 

语法:

do {

​	语句;

}while(条件表达式)

在执行时,先执行循环体,循环体执行完毕后,再对while后的条件表达式进行判断 . 结果为true时继续执行循环体 , 执行完毕继续判断以此类推 ; false时终止循环 .



区别:功能类似,但是while先判断后执行, 不能保证循环体执行 ; do..while先执行后判断 , 可以保证循环体至少执行一次. 



### for循环

最常用

在for中有专门的位置来放置三个表达式:

- 初始化表达式
- 条件表达式
- 更新表达式

语法:

for(初始化表达式 ; 条件表达式 ; 更新表达式){

​	循环体;

}

执行流程:

- 执行初始化表达式,初始化变量
- 执行条件表达式时,判断是否循环 : 为true,执行循环体 ; false,终止循环
- 执行更新表达式,更新表达式执行完毕继续重复条件表达式

这三个表达式都可以省略,也可以放在外部 . 如果不写任何表达式`for( ; ; ){ }` ,是死循环 .

```javascript
//输出100以内所有的质数
let flag = true
for (let i = 2; i <=100; i++) {  //打印2-100之间所有的数
    //判断i是否是质数
    for (let j = 2; j < i; j++) {
        if (i%j == 0){  //判断i能否被j整除
            //如果进入此判断则证明i不是质数
            flag = false
        }
    }
    if (flag){
        console.log(i);
    }
}
```

## break和continue

**break**用来**退出**switch或循环语句.不能用于if .

只会终止整个的这一层循环(离它最近的) . 

可以为循环语句创建一个label(标记) , 来表示当前循环 . 

label: 循环语句   使用break时,可以在break后跟着一个label,这样就会结束指定的循环,而不是最近的 .

**continue**(继续) : 可以用来**跳过本次**循环 . 默认只会对离他最近的循环起作用 . 



# 对象 Object

其他的五中类型属于基本数据类型,只要不是以上五种类型,那就全都是对象 . 

**万物皆可为对象!!!**

**基本数据类型都是单一的值** , 值和值之间没有任何的联系 . 

如果我们使用基本数据类型的数据,我们所创建的变量都是独立的不能成为一个整体 . 

**对象属于一种==复合的数据类型==,在对象中可以保存多个不同数据类型的属性** . 

**分类** :

- 内建对象  --  有ES标准中定义的对象,任何ES的实现中都可以使用 
- 宿主对象  --  有JS运行环境提供的对象,目前来讲主要指的是浏览器提供的对象,比如BOM , DOM
- 自定义对象  --  由开发人员自己创建的对象 , 以下的对象内容讲的都是自定义



`属性名:属性值`  名:值对  就是键值对!!就是它!kv对!



增删改查,四个基本操作 . 

在对象中保存的值成为属性 . 

向对象**==添加==**属性  语法: `对象.属性名 = 属性值 ; `  赋值

**==读取==**对象属性  语法: `对象.属性名`     如果读取对象中没有的属性,返回undefined . 

**==修改==**对象属性值  语法: `对象.属性名 = 新属性值 ;`  .

**==删除==**对象属性值 语法 : `delete 对象.属性名 ;`  . 



==**`for...in`语句**== , 对象总有几个属性,循环体就会执行几次 . 每次执行时,会将对象中一个属性的名字赋值给变量 .    遍历啦遍历啦    `for(let n in obj){}`   .  `obj[n]`找到的是n变量属性里的属性值 . 

## 创建对象

使用new关键字调用的函数,是构造函数constructor , **构造函数是专门用来创建对象的** . 

用构造函数创建对象:  `let obj = new Object();`  

用对象字面量创建对象:  `let obj = {};`  优点是可以在创建对象时,直接指定对象中的属性 : `{属性名:属性值;属性名:属性值;属性名:属性值;}`  . 属性名加不加引号无所谓 , 但是使用特殊名字时必须加引号 . 

用工厂方法创建对象 :  通过此方法可以大批量创建对象 . 由于使用的构造函数都是Object , 所以创建的对象都是Object这个类型 , 导致无法创建多个类型对象 . 

```javascript
function createPerson(name,age){
	let obj = new object();  //创建一个新对象
		obj.name = name; //向对象中添加新的属性
		obj.age = age;
		obj.sayName = function(){
			alert(this.name)
		};
    return obj ;
}
let obj2 = createPerson("蝴蝶精",18);   //批量生产了
```

## 构造函数

不是类, 是创建类的方法 . 

构造函数就是一个普通函数,创建方式和普通的没区别 , 不同的是**构造函数习惯首字母大写** . 

构造函数和普通函数的不同就是调用方式不同 , 普通函数是直接调用 , 而**构造函数需要使用new关键字来调用** . 

执行流程 : 

- 立刻创建一个新的对象
- 将新建的对象设置为函数中的this , 在构造函数中,可以**==使用this来指代新建对象==** 
- 逐行执行函数中的代码
- 将新建对象作为返回值返回

使用同一个构造函数创建的对象 , 称为一类对象 , 也**==将一个构造函数称为一个类==** .  把**==通过一个构造函数创建的对象 , 称为是该类的实例==**  .  终于知道vue中说的实例是什么了!!!   实例就是`let vm = new Vue(){ }`中的vm啊 , Vue就是那个构造函数,那个类啊!

使用`instanceof`可以检查一个对象是否是一个类的实例  语法 : `对象 instanceof 构造函数`  如果是返回true , 不是返回false . 

解决在构造函数内部创建功能相同的方法 的问题 :

如果在构造函数内部创建方法 , 会导致每执行一次都会创建一个新的方法 , 这些方法互不干扰 , 如果这些方法功能是一样的 , 那这样就是完全浪费 .  解决办法就是全局调用啦~把函数全局定义 , 然后在实例内部`this.num = fun`引用 , 但是这个方法会污染全局作用域的命名空间 , 而且也不安全 .  

那这个问题又咋螺旋上升解决问题 , 看原型对象吧 ~(提示 , 要放在原型对象中哦)

## 原型对象

创建的每个函数,解析器都会向函数中添加一个`prototype`属性 , 这个属性对应着一个对象 , 这个对象就叫做原型对象 . 每个函数的**此属性唯一** .  

**作用** : 

当函数作为普通函数调用 , prototype没作用 . 

当函数以构造函数的形式调用时 , 他所创建的对象中都会有一个**==隐含属性==**指向该构造函数的原型对象 . 可以通过`__proto__`来访问该属性 . 

**原型对象相当于一个==公共区域==** , 所有同一个构造函数的实例都可以访问到这个原型对象 , 我们可以**==将对象中共有的内容添加到构造函数的原型对象中==**   : `my.prototype.gongyou = 123;` , 好处是不用分别为每一个对象添加 , 也不会影响到全局作用域 , 就可以使每个对象都具有这些属性和方法 . 

因为原型对象也是对象 , 所以...他也有原型 ! 就是自己 . 当我们访问一个对象的属性或方法时 , 会先在对象自己身上寻找 , 没有时会在原型对象中寻找  , 如果原型对象中还没有 , 就在原型对象的原型中寻找  `对象.__proto__.__proto__` .  直到找到object对象原型 , **object的原型没有原型** . 如果object原型还没有就返回undefined . 

**in运算符** : 通过该运算符可以**检查一个对象中是否含有指定的属性** , 有返回true ,没有返回false .  如果对象中没有但是原型中有也会返回true . 语法: `"属性名" in 对象` .

但是使用 `对象.hasOwnProperty("属性名")` 来检查**对象自身中**是否含有指定属性时 , 只检查自身 , 和原型没关系哦 . 

   `对象.__proto__.__proto__.hasOwnProperty("hasOwnProperty")`  .这是检查原型对象的原型的自身的自身 .    ????迷了

总结 ??? : 对象构造的隐式原型对应构造函数的显示原型 . 

## 属性名和属性值

属性名 : 不强制要求遵守标识符规范 , 但是尽量还是按照标识规范 . 

有两种方式来读取属性名 :  `对象.属性名` & `对象["属性名"]` . 

使用`[]`操作属性会更加灵活,在[]中传递一个**变量**,这样变量值是多少就会读取那个属性 . 

属性值 : js对象的属性值,可以是任意的数据类型 ,包括object , 当然也可以是函数了!  可以对象套娃哦~

## 基本数据类型和引用数据类型

- 基本数据类型 : String  Number  Boolean  Null  Undefined  数据互相独立,不相互影响
- 引用数据类型 : Object

js中的内存都是栈内存 , 基本数据类型的值直接在栈内存中存储 . 

对象是保存在堆内存中的 , 每创建一个新的对象,就会在堆内存中开辟出一个新的空间 , 而**==变量保存的是对象的内存地址(对象的引用)==** . 如果两个变量保存的是同一个对象引用 , 当一个通过一个变量修改**属性**时,另一个也会受到影响 .   直接修改成值不会受影响,额...我觉得是数据类型变了吧,变了就和对象的内存地址没联系了 . 

当我们比较两个基本数据类型的值时,就是比较值, 而比较两个object时,比较的是内存地址 . 如果两个对象一模一样,但是地址不同,也会返回false . 

两个的根本区别是 : **基本数据类型保存的是值,而引用数据类型保存的是==地址==** .  要不然为啥叫引用呢  好像也有点道理  ... 

## 垃圾回收(GC)

当一个对象没有任何的变量或属性对它进行引用时 , 它会变得永远无法操作 , 此时它就是一个垃圾 , 当这种垃圾对象过多时就会占用大量内存空间导致程序运行变慢 . 

js中有自动垃圾回收机制 , `obj = null` , 将不用的对象设置为`null` .

## Date()对象

`new Date()` 当前时间

`new Date("月/日/年 时/分/秒")` 指定时间

`getDate()` 获取当前日期对象是几日

`getDay()` 获取当前日期对象是周几 , 周日是0

`getMonth()` 获取当前时间对象月份,返回0~11

`getFallYear()` 获取当前日期对象年份(xxxx)

`getHours()`&`getMinutes()`&`getSeconds()`&`getMilliseconds()` 返回Date对象的小时&分钟&秒数&毫秒(0~999) 

`getTime()` 返回当前日期对象的时间戳   时间戳就是指的是从格林威治标准时间的1970/1/1 0:0:0 到当前日期所花费的毫秒数 , 计算机底层在保存时间时都用时间戳 .

`Date.now()`  这一刻的时间戳

## 特殊的Math

Math和其他对象不同 , 他不是构造函数 ,不用创建对象 , 它是工具类 , 里面封装了数学运算相关的属性和办法 . 

### Math 对象属性(部分)

| 属性   |                    描述                    |
| ------ | :----------------------------------------: |
| PI     |       返回圆周率（约等于3.14159）。        |
| LOG10E | 返回以 10 为底的 e 的对数（约等于0.434）。 |
| LN10   |    返回 10 的自然对数（约等于2.302）。     |
| LOG2E  | 返回以 2 为底的 e 的对数（约等于 1.414）。 |

### Math 对象方法(常用)

| 方法         |                           描述                           |
| ------------ | :------------------------------------------------------: |
| abs(x)       |                     返回数的绝对值。                     |
| **random()** | **生成 0 ~ 1 之间的随机数**  . `floor(random()*10)+1`  . |
| **round(x)** |             **把数四舍五入为最接近的整数。**             |
| **floor(x)** |                      **向下取整** .                      |
| max(x,y)     |      返回 x 和 y 中的最高值。(获取一堆数中的最大值)      |
| **ceil(x)**  |                      **向上取整** .                      |
| min(x,y)     |      返回 x 和 y 中的最低值。(获取一堆数中的最小值)      |
| pow(x,y)     |                    返回 x 的 y 次幂。                    |

**生成一个x~y之间的随机数** :  `Math.round(Math.random()*(y-x)+x)`  也可以用floor , 除了写法不一样,功能一样的 .

# 函数

函数也是一个对象 .  具有所有普通对象的功能 . 

函数中可以封装一些功能(代码),在需要的时候执行这些功能 . 

可以保存一些代码在需要的时候调用 . 

构造函数创建函数对象 : `let fun =  new Function();`   可以将要封装的代码以字符串的形式传递给构造函数 . 封装到函数的代码不会立即执行,只有在调用的时候按照顺序执行 .   不用它 .

函数声明创建函数对象  :  `function 函数名([形参1,形参2....]) { 语句 ;}` . 

函数表达式创建对象 :  `let 函数名 = function ([形参1,形参2....]) { 语句 ;}`  **把创建的==匿名函数==赋值给变量** . 

调用函数  :  `函数对象 () `构造函数的调用  & `function  函数对象(){ }`函数声明的调用   & `函数对象 ()  ` 函数表达式调用 . 

全局对象里的函数都会作为window对象的方法保存 , 这就是说函数和方法为什么没有区别的原因 , 因为函数也是一个方法呀   就是说 ! 方法就是对象里的函数 !

## 函数的参数

形参 : 可以在函数的()中指定一个或多个形参(**形式参数**) `function sum(m,n)`  多个形参用`,`隔开 , 声明形参就相当于在函数内部声明了对应变量,但是并不赋值 . 

实参 : 在调用参数时,可以在括号中指定实参(**实际参数**) , 实参会将赋值给函数中对应的形参 .   

**实参可以是任意数据类型** , 当然对象也可以 , 当参数过多时可以封装到对象 , 然后通过对象传递 .    

当然**==函数也可以作为实参==**啦 , 并且还很常用 . 因为函数是对象 , 对象能干的事函数都能干 .   如果是函数的话 , 此时这个当参数的函数就是**回调函数**了 .   `fun(han)`调用函数 ; `fun(han())`调用函数返回值 .

调用函数时解析器不会检查实参的类型 , 所以要注意 ,是否有可能会接收到非法的参数 , 如果有可能则需要对参数类型进行检查 .  

多余的实参不会被输出 .   

如果实参的数量少于形参的数量 , 则没有对应实参的形参都将是undefined . 

## 返回值

-  **return的作用就是不要让结果出来立即执行啊,是一个返回值啊,需要==等待接收才会执行==啊 !** 
- 可以使用 return 值 来设置函数的返回值 .
-  return后的值会作为函数的执行结果返回 , 可以定义一个变量来接收该结果 .  
- return后**没有值时或者函数中==不写return时==都会返回undefined** . 
-  return后可以跟任意数据类型 ,当然也包括对象了! 当然也有函数!
- 使用return可以结束整个函数 . 

## 立即执行函数

函数定义万立即被调用,这种函数叫做立即执行函数 ,  立即执行函数往往只会执行一次(因为找不到变量保存) ,  let太浪费 , 给函数外加括号 , 表示这是一个函数对象 , 然后后面再加一个括号来接收这个函数 . 

```JavaScript
(function(){  //加括号表示这是一个函数对象
	alert("匿名函数对象");
})();  
//匿名函数对象
```

## this&arguments

**this和arguments都是在调用函数时 , 浏览器传递进函数内部的隐含参数** . 

解析器在调用函数每次都会向函数内部传递进一个隐含的参数,就是this , this指向的是一个对象 , 这个对象我们称为函数执行的**上下文对象**(this) .

**this**:

 根据函数的**调用方式**不同 , this指向不同对象 . 

- 以函数形式调用时 , **this永远是window** .
- 以方法形式调用时, **this是调用方法的那个对象**.    因为方法就是对象里的函数 .   就是谁调用了方法啊!要说清楚啊!this指的就是这个 , 它是一个指向 .
- 以构造函数的形式调用时 , **this就是新创建的那个对象** .
- 使用call和apply调用时 , this是指定的那个对象 .

**arguments** : 

封装实参对象 , 它是一个**类数组对象** , 也可以通过索引操作数据 .

 `arguments.length` : 可以用来获取实参的长度(传递的实参数) .  

在调用函数时 , 传递的实参都会在arguments中保存 . 

即使不定义形参也可以通过arguments来使用实参 .  通过`arguments[index]`获取实参.

`arguments.callee` : 这个属性对应一个函数对象 , 就是当前正在指向的函数对象 .

## 函数方法call&apply(指定this)

函数也是一个对象 , 那么它也可以有方法 .

`fun()`这就是函数对象返回值  ,`fun`才是函数对象

`fun.apply(obj)`  `fun.call()` 这就是函数对象的方法   ...

这两个函数对象的方法需要通过函数对象调用,就是上面那个 . 可以将一个对象**指定为第一个参数** , 此时**==这个对象将会成为函数执行时的this==** .  参数是谁,this就是谁 .

apply和call的区别就是 :call可以直接在对象后将实参依次传递 ; 而apply却需要将实参封装到数组中统一传递 . 

# 作用域

作用域指一个变量的作用范围 . 

js中一共有两种作用域(整体与局部的关系,学校与班级的关系) : 

**全局作用域**  : 

直接写在script标签中的js代码,都在全局作用域 .

全局作用域在页面打开时创建,关闭时销毁 .

 在全局作用域中有一个全局对象window , 它由浏览器创建 , 可以直接使用 . 

在全局作用域中 , 创建的变量都会作为window对象的属性保存 . 

 在全局作用域中 , 创建的函数都会作为window对象的方法保存 . 

**全局作用域中的变量都是全局变量 , 在页面的任意部分都可以访问到** . 

使用var关键字使变量声明提前 , 会在所有代码执行之前被声明(不会被赋值) , 但是如果声明变量是不适用var关键字,则不会被声明提前 . 

使用函数声明形式创建的函数`function 函数名(){ }` 使函数声明提前,他会在所有代码执行之前就被创建 , 所以可以在函数声明前调用 .  和var一样一样的...

**函数作用域**  :

调用函数时创建函数作用域 , 函数执行完毕后 , 函数作用域销毁 . 

每调用一次函数就会创建一个新的函数作用域 , 他们之间相互独立 . 

**==在函数作用域中可以访问到全局作用域的变量  ; 全局作用域访问不到函数作用域里的变量==** . 

当在函数作用域中操作一个变量时, 先会在自身作用域中寻找(就近原则) , 如果有就使用 , 没有就向上一级寻找 , 直到找到全局作用域哦 .  如果全局作用域中依然没有找到 , 则会报错`referenceError` . 

在函数中想要访问全局变量时就使用window(因为有就近原则存在) . 

在函数作用已也有声明提前的特性 , 使用var关键字声明的变量 , 会在函数中所有代码执行之前被声明 , 也会在所有代码执行之前执行 .

在函数中不使用var声明(或许说的是**不声明)的变量都会成为全局变量**(前提是被调用) .  

形参就相当于在函数中声明了变量 . 

# 数组

数组当然也是一个对象了 !!!

数组使用数字来作为**索引(index)**操作元素(即属性) . 

数组存储性能比普通对象好 . 

数组中的元素可以是任意的数据类型 ,  不要再问了 , 当然包括对象 !还可以是数组

添加元素 : 语法:  `数组[索引] = 值;` .

读取不存在的索引返回undefined . 

`数组.length` 获取数组长度 ,  length可以修改 .  数组长度=最大索引值+1

可以用 `arr[arr.length]` 在数组最后面添加元素 . 

## 创建数组

创建数组 : `let arr= new Array();` .

使用字面量创建数组: 语法 : `let arr = []`

使用构造函数创建数组时, 可以同时添加元素 .

## 对象方法

- `push()` : 向数组的末尾**添加一个或多个元素 , 并返回数组新的长度** . 可以将要添加的元素作为方法的参数传递 , 这些元素会自动添加到末尾 .  
- `pop()` : 删除数组的最后一个元素 ,并将删除元素作为返回值返回 .  调用一次删除一次 .
- `unshift()` : 向数组的**开头**添加一个或多个元素 , 并返回新的数组长度 .  其他元素索引会依次调整 . 
- `shift` : 删除数组的第一个元素 , 并将删除元素作为返回值返回 . 
- `slice()` : 从某个已有的数组**返回选定的元素** .  `数组对象.slice(截取开始位置索引,截取结束位置索引)`  . 该方法**不会改变原数组** , 而会将截取到的元素封装到一个新数组中返回 .  截取开始位置索引包含开始索引 ; 而结束位置索引不包含结束索引 .  如果第二个参数不写 , 则返回从开始位置往后所有的元素 .   索引也可以传递一个负值 , 如果传递负值则从后往前结束 .
- `splice()` : 用于删除数组中指定元素 , 并添加新元素 .  `slice(开始位置索引,删除个数,插入的元素,插入元素...)`  .  会改变原数组 , 并**将被删除的元素作为返回值返回** .  插入的元素会自动插入到开始位置索引的前面 .  这个方法很有意思的 , 可以删除添加和替换 .
- `sort()` : 给数组元素进行排序 , 默认从小到大(按照Unicode编码排序) . 会对原数组产生影响 .  可以自己制定排序规则 `arr.sort(function(a,b){return a - b;})` , 在这里需要定义两个形参 , 浏览器会分别使用数组中的元素作为实参去调用回调函数 , a一定在b前面 . 把返回值和0比较,决定会不会交换位置,大于0会换位置 . 升序排列a - b;降序b-a .
- `concat()` : 连接两个或更多的数组并返回结果 .   `color = arr1.concat(arr2,arr3,"新元素","新元素")`   不会对原数组产生影响 . 
- `join()` : 将数组转换为一个字符串 , 将字符串作为结果返回 . 不会对原数组产生影响 . 可以指定一个字符串作为参数 , 这个字符串将会成为数组中元素的连接符 , 默认使用逗号 .
- `reverse()`  : 该方法用来反转数组(前后颠倒) . 该方法会对原数组产生影响 , 会直接修改原数组 . 

新加方法 :

- `forEach()` : 数组全部遍历 ,这种方法需要一个函数作为参数 .  只支持IE8以上的浏览器 .  由我们创建但是不由我们调用 .是回调函数
- `some()` : 如果返回return , true , 则立即终止循环 . 
- `filter()` : 过滤 , 把符合条件的返回新数组 .
- `findIndex()` : 查找索引 .

## 遍历

将数组中所有元素都取出来就是遍历 .   

`for(let i= 0 ; i < arr.length ; i++){}`  .

`数组.forEach()` 也是遍历 , 数组中有几个元素就会执行几次 , 每次执行时 , 浏览器会将遍历到的元素以实参的形式传递进来 , 我们可以定义形参来读取这些内容 . 

浏览器会在回调函数中传递三个参数 :  

- 当前正在遍历的元素 . 
- 当前正在遍历的元素的索引 . 
- 正在遍历的数组 . 

# 包装类

js中提供三个**包装类供我们将基本数据类型转换为对象** .

在实际应用中**不会使用**基本数据类型的对象 . 都是浏览器干的事!自动装箱拆箱

当我们对基本数据类型的值去调用属性和方法时 , 浏览器会临时将其包装成对象 ,然后再调用属性和方法 , 完了之后再转回来  (这些都是浏览器内部操作)

首字母大写,它们都是构造函数 .   让我想到js的语言散漫

- `String("hello")` : 将基本数据类型字符串转换为String()对象
- `Number(3) ` : 将基本数据类型数字转换为Number()对象
- `Boolean(true)` : 将基本数据类型布尔值转换为Boolean()对象

## String()[部分]

在底层字符串以字符数组的形式保存 .  `str[index]` . 

`indexof()` 检索一个字符串中是否含有指定内容 ,返回index . 可以指定第二个参数,指定开始查找的位置 .

`slice(开始位置索引,结束位置索引)` 截取字符串 , 和数组中slice()用法一样 .

`substring()` 和 `substr()`  和 `slice()`的区别  (考点)   截取字符串,都包含startIndex

`substring(startIndex,endIndex)`(包含endIndex,不使用负数)   &   `substr(startIndex,length)` (结果不包含endIndex)   &   `slice(startIndex,length)` (可以使用负数)

`concat()` 连接字符串

`split(g)` 将字符串拆分成数组 ,  需要一个字符串做参数,将会根据该字符串去拆分数组 . 如果传递空串,则会把每一个字符都拆分为数组中的一个元素 .

# 正则表达式

用于定义一些字符串规则 , 计算机根据正则表达式来检查一个字符串是否符合规则 , 获取将字符串中符合规则的内容提取出来 . 

创建方式 : `let 变量 = new RegExp("正则表达式","匹配模式");`  . **匹配模式:flags , flags有三个值:g[全局匹配] , i[忽略大小写] , m[多行查找 ,ES规则制定后才支持]** . 

`let RegExp = /正则表达式/flags;`  方便 , 但是用构造函数比较好

**`变量.test(字符串)`  检查字符串中是否含有指定内容** . 

`let isFit = reg.test(emailText)`

`split(/[A-z]/);` 将一个字符串拆分成一个数组 , 方法中可以传递一个正则表达式作为参数,这样该方法将会**根据正则表达式拆分字符串** .

`search(/a[bef]c/)` 搜索字符串中是否含有指定内容 . 如果有指定内容,则会返回**第一次**出现的索引 , 没有则返回-1 .

`match(/[a-z]/gi)` 可以根据正则表达式从一个字符串中将符合条件的内容提取出来 , 封装到数组中返回 , 即使只查询到一个结果 . 默认情况下找到第一个符合要求的内容后就会终止 , 这时需要设置正则表达式为全局模式  , **一个正则表达式可以设置多个flags,且顺序无所谓** . 

`replace("被替换的内容","新的内容")` 将指定内容替换为新内容 , 如果想删除,就把新内容设置为空 . 默认只会匹配第一个 , 设置全局模式

## 常用符号

通过设置两次可以设置一个内容出现的次数 , 但是只对它前面的一个内容起作用 .

==**`[ab]` == `a|b`**== . `[a-z]`任意小写字母 .  `[A-z]`任意字母 .   `[^ab]`除了ab . 

`{n}` 重复n次    `{n,}` 重复n次以上       `{n,m}` 重复n次到m次

`n+` 至少一个,相当于`{1,}`       `n*` 零次或更多次,相当于`{0,}` 

`^` 匹配字符串开始   `$` 匹配字符串结束  如果同时使用这两个字符,表示必须完全符合正则表达式 .

手机号 : `^a[3-9][0-9]{9}$` 

`\` 转义字符  , 注意:是用构造函数时 , 由于它是参数的一个字符串,而\又是转义字符,所以单独写`\`时必须写成`\\`,把自己转义了 .

**`\w`  匹配字母,数字,下划线,数字,汉字** .  `\s` 匹配任意空白字符 .  `\d` 匹配数字 .  `\b`  匹配单词的开始或结束 .

`\W` 匹配非字母,数字,下划线,数字,汉字的字符 .  `\S` 匹配非空白字符 .  `\D` 匹配非数字的字符 .  `\B`  匹配不是单词开始或结束的位置 .

`replace(/^\s*|$\s*/g)` 匹配开头和结尾的空格 .

`()`内的内容**表示的是一个==子表达式==**，本身不匹配任何东西，也不限制匹配任何东西，只是把括号内的内容作为同一个表达式来处理 .

邮箱地址 : `/^\w+(\.\w+)*@\w+([-.]\w)*\.\w+([-.]\w+)*$/`






















## async/await用法和理解



## js数组处理的四个方法

find()   filter()    map()    forEach()

## computed和watch的区别

**计算属性computed**.本质上是vue实例对象上的一个属性. 会自动监测数据源的改变：只有数据源发生变化才会重新执行计算属性，否则会返回缓存中的上次的计算结果。**计算属性的监听适用于多对一的场景，即某个组件内的一个数据(add)会受多个数据(num1,num2)的影响(比如add=num1+num2)(多个影响一个)。**不限制响应式依赖(就是data中的数据,在computed里是this.msg)的个数和数据类型,会多个同时监听 .    比methods先执行,要写在methods前面.   不能用箭头函数,会使指向混乱.    默认深度监听.   其中的函数必须用return返回.    使用情景:例如商品结算,计算总值时.

**监听器watch**:**`watch`的监听适用于一对多(一个影响多个)的场景**，即某个组件内的一个数据的改变会影响其他多个数据。  设置`deep:true`或者直接点(.)到想监听的数据上,才会深度监听.    适用场景:例如搜索框.

## vue中ref的用法



## 函数防抖和节流

防抖:防抖就是指**触发事件后在n秒内函数只能执行一次,如果在n秒内又触发了事件,则会重新计算函数执行时间**.      例如我们想监听搜索框,用户快速输入一连串字符就会瞬间触发十次请求,但是我们想要的是停止输入再触发请求.

节流:节流就是指**连续触发事件但是在n秒中只执行一次函数**.节流会稀释函数的执行频率,避免在间隔内函数的过多执行.    例如滚动浏览器滚动条的时候,更新页面的布局内容.

## cookie,localStorage,sessionStorage的区别

`cookie`一般由服务器生成,它的数据始终在http请求中携带,会在浏览器和服务器间来回传递;而`sessionStorage`和`localStorage`不会把数据发给服务器，仅在本地保存.      在数据大小方面也有差别:`cookie`数据大小有4k左右,其他两个一般为5M,比cookie大得多.      `Cookie`可以设置数据存储时间,`localStorage`长期存储数据,关闭浏览器数据不丢失;`sessionStorage`关闭浏览器后数据自动删除.

## 浏览器缓存机制(简单理解)

浏览器缓存就是把已经请求过的资源拷贝一份放到浏览器中.当下一个请求到来时,如果是相同的url,浏览器会根据缓存机制决定是使用副本还是向源服务器发起请求.         浏览器缓存定义在http协议头部和HTML页面的meta标签中.从过期机制和验证机制两个维度来决定.

判断是否在缓存有效时间内,在有效时间内就用强制缓存,非有效时间就用`Etag`(唯一标识)与传输过来的字段进行比较,如果相等表示未修改,响应304,可以继续使用缓存;反之响应200,返回数据.

 使用缓存的原因:1.减少网络带宽消耗;2.减少请求,间接降低服务器压力;3.可以明显加快页面打开速度,减少网络延迟.

## 强制缓存(200)和协商缓存(304)

**强制缓存**:用户发送的请求直接从客户端缓存中获取，不发送请求到服务器，不与服务器发生交互行为。     **协商缓存(对比缓存)**:用户发送请求到服务器之后，由服务器判定是否从缓存中获取资源。 

这两种缓存获取的数据都是从客户端的缓存中获取,区别在于是否与服务器发生交互.   强制缓存优先级更高.

## this



## js各种继承方式和优缺点介绍



## 原型链和继承



## vue中的nextTick()(简单理解)



## vue中的v-for中为什么要加:key(key的作用)

因为我们需要key来给每个节点做一个唯一标识,在diff算法中通过key精准判断是否同一个节点,来高效的更新虚拟DOM.  除此之外,在使用相同标签名元素的过渡切换时，也会使用到key,让vue可以区分它们.

## vue中$router和$route的使用

`$router`是vue-router的实例,相当于一个全局路由对象,里面有很多属性和子对象.常用的跳转链接就可以用`this.$router.push`,和`router-link`跳转一样.   而`$route`是当前正在跳转的路由对象,可以从里面获取name,path,params等对象

## vue-router原理



## 组件的几种通信方式



## vue项目中的自适应布局



## vue-路由守卫(导航守卫)



## 弹性布局属性详解



## webpack打包原理

webpack是把项目当作一个整体，通过给定的一个主文件，webpack将从这个主文件开始找到你项目当中的所有依赖的文件，使用loader来处理它们，最后打包成一个或多个浏览器可识别的`bundle.js`文件.通过代码分割成单元片段并按需加载.

关于核心思想:1.一切皆模块---所有文件都可以视作模块,意味着可以将业务分割成更多单元片段,达到复用目的;2.按需加载---利用许多特性来分割代码生成多个`bundle.js`文件,以实现异步加载.

关于文件管理:每个文件都是一个资源,可以用require/import导入js;每个文件会把自己依赖的资源全部打包在一起,一个资源引用多次的话只打包一份;对于多个入口的情况,其实就是分别独立的执行单个入口情况,每个入口文件不相干.

`loader`是webpack最重要的部分之一，通过使用不同的Loader，我们能够调用外部的脚本或者工具，实现对不同格式文件的处理，loader需要在webpack.config.js里边单独用module进行配置.




























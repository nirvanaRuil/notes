## async/await用法和理解

**Async/await**:`Async/await`其实是`generator/yield`的语法糖.generator函数从内部向外返回数据,并且会分段执行,yield语句就是就是暂停执行的标记.generator函数的特点是分段执行可以暂停;可以控制阶段和每个阶段的返回值;可以知道是否进行到结尾.async函数的返回值总是返回promise实例,await用在async函数中,后面是promise实例,如果不是则会用promise.resolve()转为实例,所以就有了比较精简的写法.await左边的变量就是promise成功后的resolve数据.

## 闭包

延伸函数环境生命周期

内存泄漏问题:无法销毁驻留在内存中的元素,内存泄漏的解决之法就是手动置空: obj = null; . 

闭包最重要的一个作用就是把某些变量隐藏起来,让外面的程序不能直接访问.因为局部变量只在局部有效,出了局部就回收了,但是有些变量既需要隐藏又需要长期保持,这时候闭包就是最好的解决方法 .  

具体场景:函数防抖,设计单例模式,设置私有变量,为多个组件独立属性.

闭包是一个封闭的隔离的空间，它是一个可以访问到其他函数作用域的函数.因为在全局中，受链式作用域结构的影响，父级变量中无法访问到子级的变量值，为了解决这个问题，才使用闭包这个概念。闭包的特性：①.封闭性：外界无法访问闭包内部的数据，如果在闭包内声明变量，外界是无法访问的，除非闭包主动向外界提供访问接口;②.持久性：一般的函数，调用完毕之后，系统自动注销函数，而对于闭包来说，在外部函数被调用之后，闭包结构依然保存在 系统中，闭包中的数据依然存在，从而实现对数据的持久使用。优点：①减少全局变量。②减少传递函数的参数量③封装；缺点：使用闭包会占有内存资源，过多的使用闭包会导致内存泄露等.

## js数组方法

**Array.from()** :用于将类数组对象和可遍历的对象(包括Map和Set)转换为真正的数组.

**Array.of()** :将一组值转换成数组,基本可以替代Array(),不存在参数不同导致的重载.

**filter()** :用来过滤数组中不满足条件的元素,把满足条件的元素放到新的数组里,不改变原数组.

**map()**  :主要用来创建新数组,参数和`forEach`相同.但是使用map遍历数组,会返回一个新的数组,不改变原数组的内容.也可以`map(string)` .

**forEach()**:会遍历数组,循环体内内有返回值;循环不会改变原来数组内容.有三个参数--当前元素,当前元素的索引,当前元素所属数组.  他有一个问题就是不能跳出整个循环.

**some()**:遍历数组,根据循环体内条件去判断,只要有一个是true就停止循环.

**every()**:和some不同的是,它的判断如果每一项都是true才会返回true.

## computed和watch的区别

**计算属性computed**.本质上是vue实例对象上的一个属性. 会自动监测数据源的改变：只有数据源发生变化才会重新执行计算属性，否则会返回缓存中的上次的计算结果。**计算属性的监听适用于多对一的场景，即某个组件内的一个数据(add)会受多个数据(num1,num2)的影响(比如add=num1+num2)(多个影响一个)。**不限制响应式依赖(就是data中的数据,在computed里是this.msg)的个数和数据类型,会多个同时监听 .    比methods先执行,要写在methods前面.   不能用箭头函数,会使指向混乱.    默认深度监听.   其中的函数必须用return返回.    使用情景:例如商品结算,计算总值时.

**监听器watch**:**`watch`的监听适用于一对多(一个影响多个)的场景**，即某个组件内的一个数据的改变会影响其他多个数据。  设置`deep:true`或者直接点(.)到想监听的数据上,才会深度监听.    适用场景:例如搜索框.

## vue中ref的用法

基本用法是用ref获取页面的dom元素.  this.$refs获取子组件的data , 调用子组件的方法 .   父组件用this.$refs()传方法,子组件用this.$emit接收实现父向子传方法.

## 组件的几种通信方式



## 函数防抖和节流

防抖:防抖就是指**触发事件后在n秒内函数只能执行一次,如果在n秒内又触发了事件,则会重新计算函数执行时间**.      例如我们想监听搜索框,用户快速输入一连串字符就会瞬间触发十次请求,但是我们想要的是停止输入再触发请求.

节流:节流就是指**连续触发事件但是在n秒中只执行一次函数**.节流会稀释函数的执行频率,避免在间隔内函数的过多执行.    例如滚动浏览器滚动条的时候,更新页面的布局内容.

## cookie,localStorage,sessionStorage的区别

`cookie`一般由服务器生成,它的数据始终在http请求中携带,会在浏览器和服务器间来回传递;而`sessionStorage`和`localStorage`不会把数据发给服务器，仅在本地保存.      在数据大小方面也有差别:`cookie`数据大小有4k左右,其他两个一般为5M,比cookie大得多.      `Cookie`可以设置数据存储时间,`localStorage`长期存储数据,关闭浏览器数据不丢失;`sessionStorage`关闭浏览器后数据自动删除.

## 浏览器缓存机制(简单理解)

浏览器缓存就是把已经请求过的资源拷贝一份放到浏览器中.当下一个请求到来时,如果是相同的url,浏览器会根据缓存机制决定是使用副本还是向源服务器发起请求.         浏览器缓存定义在http协议头部和HTML页面的meta标签中.从过期机制和验证机制两个维度来决定.

判断是否在缓存有效时间内,在有效时间内就用强制缓存,非有效时间就用`Etag`(唯一标识)与传输过来的字段进行比较,如果相等表示未修改,响应304,可以继续使用缓存;反之响应200,返回数据.

 使用缓存的原因:1.减少网络带宽消耗;2.减少请求,间接降低服务器压力;3.可以明显加快页面打开速度,减少网络延迟.

## 强制缓存(200)和协商缓存(304)

**强制缓存**:用户发送的请求直接从客户端缓存中获取，不发送请求到服务器，不与服务器发生交互行为。     **协商缓存(对比缓存)**:用户发送请求到服务器之后，由服务器判定是否从缓存中获取资源。 

这两种缓存获取的数据都是从客户端的缓存中获取,区别在于是否与服务器发生交互.   强制缓存优先级更高.

## this

**this**:**this永远指向最后调用它的那个对象**,而在箭头函数中的this指向函数定义时的this.,不是执行时的this.  匿名函数this指向window.

 **改变this指向**:使用ES6箭头函数;在函数内部使用`_this=this`;使用apply,call,bind;new实例化一个对象.   apply和call的区别是---apply传入的是参数列表,call是参数数组.

**箭头函数**:没有this.没有原型.不能使用new.

## js各种继承方式和优缺点介绍

**原型链继承**:将父类的实例作为子类的原型,但是引用属性被所有实例共享;   **构造函数继承**:使用父类的构造函数来增强子类实例,等于是赋值父类的实例属性给子类,避免了实例共享但是每次创建实例都会创建一次方法;   **组合继承**:原型链继承和构造函数继承的组合.通过调用父类构造,继承父类的属性并保留传参,然后通过将父类实例作为子类原型,实现函数的复用.是最常用的继承方式 ;   **寄生组合继承**:通过寄生的方式砍掉父类的实例属性,这样在两次调用父类构造函数的时候就不会两次初始化方法属性,与此同时原型链保持不变. 它应该是引用类型最理想的继承方式.

## 原型链和继承

原型的作用是数据共享,节约内存空间.也能实现继承.它把所有对象公用的属性全部放在堆内存的一个实例对象中,然后让每一个proto对象存储这个地址.这个共用属性就是原型.而原型链就是对象通过proto向当前实例所属的原型上查找属性和方法的机制,如果根据原型链找到object的原型上还没有找到想要的属性和方法的话,就会返回undefined.

## vue中的nextTick()(简单理解)



## vue中的v-for中为什么要加:key(key的作用)

因为我们需要key来给每个节点做一个唯一标识,在diff算法中通过key精准判断是否同一个节点,来高效的更新虚拟DOM.  除此之外,在使用相同标签名元素的过渡切换时，也会使用到key,让vue可以区分它们.

## vue中$router和$route的使用

`$router`是vue-router的实例,相当于一个全局路由对象,里面有很多属性和子对象.常用的跳转链接就可以用`this.$router.push`,和`router-link`跳转一样.   而`$route`是当前正在跳转的路由对象,可以从里面获取name,path,params等对象

## vue-router原理

前端路由的核心之一就是更新视图但不重新请求页面,通过hash和History interface(H5新特性)两种方式实现.   路由的mode参数决定采用哪种方式,默认是hash(#)方式.    当你选择mode类型之后，程序会根据你选择的mode 类型创建不同的history对象(HashHistory或HTML5History或AbstractHistory). hash方式下可以用push和replace替换路由---push将新路由添加到浏览器访问历史的栈顶,而replace直接替换当前路由.  history可以读取浏览器历史记录栈的信息并修改.

## vue项目中的自适应布局和响应式布局

响应式布局包括自适应布局.自适应布局是根据页面大小调整状态,页面不变.

视口分为布局视口,视觉视口和理想视口.

怎么设置?在代码头部添加`meta-viewport`标签;在代码中尽量少的使用绝对宽度;可以通过媒体查询加rem&less来实现---rem布局的缺点是css样式和js代码有一定的耦合性,如果浏览器大小改变需要改变的样式很多,而且必须把改变font-size的代码放在css样式之前.   通过百分比布局,但是它的计算比较困难,而且相对父元素的属性并不唯一  ;  通过flex布局.

## px和rem和em的区别

都是长度单位,但是px值是固定的便于计算;em值不`固定,是相对单位,会继承父级元素的字体大小。比如字体默认16px,那么1em=16px。    Em和rem区别在于使用rem为元素设定字体大小时，仍然是相对大小，但相对的只是HTML根元素。通过它既可以做到只修改根元素就成比例地调整所有字体大小，又可以避免字体大小逐层复合的连锁反应。

## vue-路由守卫(导航守卫)

导航守卫也叫路由拦截,有三种:全局守卫,路由独享守卫和组件内守卫.  

**全局守卫**分为全局前置导航钩子和全局后置导航钩子.在路由即将改变前和改变后触发.        前置调用`router.beforeEach((to,from,next) => {})` .有三个参数:to是进入到哪个路由去,from是从哪个路由离开,next决定是否展示你要看到的路由页面.    应用过程是这样的---判断`to`将要进入的路径,如果是,执行next()展示将要进入的路径.     next在所有逻辑路径都不重叠的情况下可以出现一至多次,否则函数不被解析或报错.     next()--直接进to 所指路由 ; next(false)--中断当前路由 ; next('route')--跳转指定路由 ; next('error')--跳转错误路由.        后置用的少,调用`router.afterEach((to,from) => {})` ,只有to和from两个参数.

**路由独享守卫**调用`beforeEnter:(to,from,next) => {}`,与全局守卫用法一致,唯一区别只是独享守卫作用在一个路由对象中,只在这个路由中起作用.

**组件内守卫**有三个钩子函数:`beforeRouteEnter(to,from,next) => {}`路由进入组件之前时,此时next用法有些不同,因为实例还未渲染,所以要调用vm来访问实例 ; `beforeRouteUpdate(to,from,next) => {}`刷新不同数据时 ; `beforeRouteLeave(to,from,next) => {}`离开当前路由组件时调用.

## 弹性布局属性详解



## webpack打包原理

webpack是把项目当作一个整体，通过给定的一个主文件，webpack将从这个主文件开始找到你项目当中的所有依赖的文件，使用loader来处理它们，最后打包成一个或多个浏览器可识别的`bundle.js`文件.通过代码分割成单元片段并按需加载.

关于核心思想:1.一切皆模块---所有文件都可以视作模块,意味着可以将业务分割成更多单元片段,达到复用目的;2.按需加载---利用许多特性来分割代码生成多个`bundle.js`文件,以实现异步加载.

关于文件管理:每个文件都是一个资源,可以用require/import导入js;每个文件会把自己依赖的资源全部打包在一起,一个资源引用多次的话只打包一份;对于多个入口的情况,其实就是分别独立的执行单个入口情况,每个入口文件不相干.

`loader`是webpack最重要的部分之一，通过使用不同的Loader，我们能够调用外部的脚本或者工具，实现对不同格式文件的处理，loader需要在webpack.config.js里边单独用module进行配置.

## vuex

它相当于一个公共仓库,保存着所有组件都能用的公共数据.

vuex的运行过程:组件派发任务到actions，actions触发mutations中的方法，然后mutations来改变state中的数据，数据变更后响应推送给组件，组件重新渲染.

vuex保存和获取数据全流程:

第一步---state.js保存所有数据,以对象的方式导出

```javascript
export default {
  pathName: '', // 路由
  currDbSource: {}, // 当前数据源
};
```

第二步:mutations.js ---保存所有方法，用来改变state的数据

```javascript
export const savePath = (state, pathName) => {
  state.pathName = pathName; // 保存当前菜单栏的路径
};
export const saveCurrDbSource = (state, currDbSource) => {  // 保存当前点击的数据源
  state.currDbSource = currDbSource;
};
```

第三步:actions.js ---暴露给用户使用，借此触发mutations中的方法，保存数据（可执行异步操作）  这里有两种方式---第一种是通过 context上下文用来触发事件，一种是直接通过commit，为了保存数据，都需要加第二个参数payload，不然保存到vuex的数据就是空值

```javascript
export const savePath = ({ commit }, payload) => {
  commit('savePath', payload);
};// 触发保存菜单栏的路径方法
export const saveDbSource = (context, payload) => {
   context.commit('saveDbSource', payload);
};// 触发获取当前点击的数据源方法
```

第四步:index.js---引入响应模块,暴露出store,供vue注册后全局使用

```javascript
import state from './state';
import * as actions from './actions';
import * as mutations from './mutations';
```

第五步:在main.js中引入index.js

```javascript
import store from './store/index';
```

第六步:保存数据     这里也有2种保存数据的方法,第一种就是---直接操作方法,通过disptach派发给actions,让actions去触发;       第二种就是----通过在methods中添加映射关系，数组方式意味着我们可以在数组中写多个方法(这里数组中的每一个方法名是actions.js文件中所定义的方法名),然后在需要使用的地方直接this.方法名即可。当然,也可以直接绑定给html中的某个事件。    

```javascript
import { mapActions } from 'vuex';
// 2种方式
// 方法一（dispatch）
this.$store.dispatch('saveDbSource', this.DbSource);
// 方法二（映射）
methods: {
    ...mapActions(['saveDbSource'])
  }  // 1、通过methods方法添加映射关系 
this.saveDbSource   // 2、使用
```

第七步:获取数据      通过计算属性，当数据发生改变，我们可以保证拿到的是响应过后的数据,也是数组形式,意味着我们可以拿到多组数据，这里数组中的数据也是state.js中定义的变量.         使用的时候,可以直接通过this.变量名拿到,我们可以把它赋给我们自定义的变量,也可以直接使用.

 `mapState`  `mapAction`这种叫辅助函数,可以辅助获得多个值

```javascript
import { mapState } from 'vuex';
computed: {
    ...mapState(['DbSource']),
},
watch: {
    DbSource(currVal) {
// 监听mapState中的变量，当数据变化（有值、值改变等），
// 保证能拿到完整的数据，不至于存在初始化没有数据的问题，然后可以赋给本组件data中的变量
      this.currVal = currVal;
    }
}
```

值的注意的是，要避免和自己定义的其他变量,方法的名字冲突